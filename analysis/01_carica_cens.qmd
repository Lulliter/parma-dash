---
title: "Mappe e Codici confini amministrativi ISTAT"
subtitle: "Materiale intermedio su dati geografici con R"
date: last-modified
date-format: "DD-MMMM-YYYY"
lang: it

format: html
  # html:
  #   theme: flatly #spacelab
    # css: utils/style.css
    # code-fold: true # redundant bc echo false 
    # toc-depth: 3
    # toc_float: true
    # toc-location: left
    # toc-title: Indice
    # embed-resources: true # external dependencies embedded (Not in ..._files/)

execute:
  eval: true
  echo: false # x mostrare codice anche in file docx
  warning: false
  error: false
  output: false
  
bibliography: ../bib/CRP_dash.bib
suppress-bibliography: false
---

## R packg

```{r}
#| label: setup

# --- Pacchetti (load but suppress warning) --- 
library(here)
library(sf)
library(readxl)
library(janitor, warn.conflicts = FALSE, quietly = TRUE)

library(dplyr, warn.conflicts = FALSE, quietly = TRUE)
library(stringr, quietly = TRUE)
library(janitor, quietly = TRUE)
library(tidyr, quietly = TRUE)

library(ggplot2, quietly = TRUE)
library(ggrepel, quietly = TRUE)
library(leaflet, quietly = TRUE)
library(tmap, quietly = TRUE)
library(flextable, quietly = TRUE)

# source(here("R","f_ft_formatting.R"))
```


## Carica dati Censimento

**FONTE**: [IstatData](https://esploradati.istat.it/databrowser/#/it/censpop) is the new Istat data warehouse.\
**QUERY STRUTTURA**: [Link](https://esploradati.istat.it/SDMXWS/rest/dataflow/IT1/DF_DCSS_POP_DEMCITMIG_TV_2/1.0/?detail=Full&references=Descendants) 
**QUERY DATI**: [Link] = `urls_istat$pop_cens_all`
**DATA AGGIORNAMENTO**: Censimento 2023 **COME OTTENUTO**: Download dati ISTAT CENSIMENTO via API SDMX (vedi `R/f_istat_scarica_cens.R`) **CONTENUTO**: + Dataset ID = "IT1,DF_DCSS_POP_DEMCITMIG_TV_2,1.0"

+ Qui uso una funzione R (`f_scarica_istat_blocchi()`) che ho scritto per **scaricare i dati censuari per comune** via API SDMX. In pratica, partendo da un url con dentro tutti i comuni italiani, mi consente di selezionare solo i comuni che mi interessano (es. quelli di Parma o di Emilia-Romagna), dividere la richiesta in blocchi (per evitare timeout/limiti di richiesta) e salvare i dati in locale in formato RDS e CSV.

### URL EsploraDati Istat
```{r}
#| label: urls_esploradati

library(yaml)
# --- URL EsploraDati Istat ---
urls_istat <- read_yaml(here::here("data","istat_queries.yml"))

# Query originale con eta (decenni per tutti i comuni italiani (io chiedo solo per 44 PR tramite arg CODICI_TERRITORIO....
urls_istat$pop_cens_all
```


### File (scarica) `dati_finali_com`

OKKIO: non lo faccio andare se so che ho gi√† i dati!!!!!

CALL API per ottenere dati censimento 2023 SOLO per i `44` **comuni di Parma (PR)** e Emilia-Romagna (ER)
```{r}
#| eval: false

# Stringhe x test codici comuni Parma e PAvia
CODICI_COMUNI_test_PR_PV <- c("034027","018110")
CODICI_PROVINCIA_test_PR_PV <- c("34","18")
```

```{r}
#| label: istat_pop_com_PR_2023-TOOLONG
#| eval: true

# 0) Codici territorio (dal file che hai generato prima)
source(here("data", "data_out", "ER_shp", "lista_PRO_COM_T_er_pr_vec.R"))
CODICI_COMUNI_ER_PR

# 1) Funzioni SDMX
source(here("R", "f_istat_scarica_cens.R"))
# Qui la `f_scarica_istat()` scarica dati per UN singolo gruppo di codici, poi `f_scarica_istat_blocchi()` = divide i codici in blocchi, chiama f_scarica_istat() pi√π volte, e unisce i risultati
# quindi io devo chiamare SOLO f_scarica_istat_blocchi() con TUTTI i codici che mi servono

# ---  Tutti gli argomenti (3 obbligatori altri opzionali hanno gi√† un default)
    # dati <- f_scarica_istat_blocchi(
    #   codici_territorio = CODICI_TERRITORIO,     # obbligatorio
    #   dataset_id = "...",                        # obbligatorio
    #   anno = 2023,                               # obbligatorio
    #   frequenza = "A",                           # default "A"
    #   dimensioni_extra = "......",               # default "......"
    #   codici_per_blocco = 10,                    # default 10 (era 15)
    #   pausa_tra_richieste = 20,                  # default 20 (era 15)
    #   pausa_dopo_errore = 30,                    # default 30
    #   timeout_sec = 120,                         # default 120 (era 60)
    #   stampa_piano = TRUE                        # default TRUE
    # )

# 2) Argomenti obbligatori per f_scarica_istat_blocchi() 
DATASET_ID        <- "IT1,DF_DCSS_POP_DEMCITMIG_TV_2,1.0"
ANNO              <- 2023 # del censimento
CODICI_TERRITORIO <- CODICI_COMUNI_ER_PR        # ---------- QUI SI DECIDE PERIMETRO

# # 3.a) Eseguo per fare API get di comuni di Parma
# dati_finali_com <- f_scarica_istat_blocchi(
#   codici_territorio   = CODICI_TERRITORIO,
#   dataset_id          = DATASET_ID,
#   anno                = ANNO,
#   dimensioni_extra = "......" # per scaricare TUTTI i dati
#    # dimensioni_extra = "..ALL.ALLALL" # per cercare di limitare i dati scaricati
#  
#   # GENDER
#   # AGE_CLASS
#   # MARITAL_STATUS
#   # CITIZENSHIP
#   # AREA_CONTRY_CITIZEN
#   # USUAL_RESID_1Y
#  )

# 3.b) [SMARTASS VERSION] Solo se istat_pop_com_PR_2023 NON esiste gi√† nella cartella here(data, data_output) , allora scaricalo
file_rds <- here::here("data", "data_out", "istat_pop_com_PR_2023.rds")

if (file.exists(file_rds)) {
  # Caso 1: il file ESISTE ‚Üí leggo da disco
  dati_finali_com <- readRDS(file_rds)
  
} else {
  # Caso 2: il file NON esiste ‚Üí scarico e salvo
  dati_finali_com <- f_scarica_istat_blocchi(
    codici_territorio   = CODICI_TERRITORIO,
    dataset_id          = DATASET_ID,
    anno                = ANNO,
    dimensioni_extra = "......" # per scaricare TUTTI i dati
    # dimensioni_extra = "..ALL.ALLALL" # per cercare di limitare i dati scaricati
    
    # GENDER
    # AGE_CLASS
    # MARITAL_STATUS
    # CITIZENSHIP
    # AREA_CONTRY_CITIZEN
    # USUAL_RESID_1Y
  )
  
  saveRDS(dati_finali_com, file_rds)
}

# In pratica posso lasciar stare le colonne che non variano: MARITAL_STATUS, AREA_CONTRY_CITIZEN, USUAL_RESID_1Y, NOTE_AREA_CONTRY_CITIZEN, TIME_PERIOD, (NOTE_REF_AREA)  (che per√≤ ha NA)
 
```


##### Controllo file `dati_finali_com`
```{r}
#| eval: false
# check
skimr::skim(dati_finali_com$REF_AREA)              # 44 unique    
skimr::skim(dati_finali_com$INDICATOR)             # 2 unique
skimr::skim(dati_finali_com$GENDER)                # 3 unique
skimr::skim(dati_finali_com$AGE_CLASS)             # 13 unique
  tabyl(dati_finali_com$AGE_CLASS)

# # gi√† eliminati
# skimr::skim(dati_finali_com$TIME_PERIOD)           # 1 unique (2023)
# skimr::skim(dati_finali_com$NOTE_REF_AREA)         # >1 unique (034051_N1 o NA)
#   tabyl(dati_finali_com$NOTE_REF_AREA)
# skimr::skim(dati_finali_com$MARITAL_STATUS)      # 1 unique (ALL)
#   tabyl(dati_finali_com$MARITAL_STATUS)
# skimr::skim(dati_finali_com$AREA_CONTRY_CITIZEN)   # 1 unique (ALL)
#   tabyl(dati_finali_com$AREA_CONTRY_CITIZEN)
# skimr::skim(dati_finali_com$USUAL_RESID_1Y)        # 1 unique (ALL)
#   tabyl(dati_finali_com$USUAL_RESID_1Y)
# skimr::skim(dati_finali_com$NOTE_AREA_CONTRY_CITIZEN)# 1 unique (ISO__ALL_N1)
#   tabyl(dati_finali_com$NOTE_AREA_CONTRY_CITIZEN)
# skimr::skim(dati_finali_com$CITIZENSHIP)           # 3 unique (TOTAL, ITL, FRGAPO)
#   tabyl(dati_finali_com$CITIZENSHIP) 
```

#### Creo mini file per variabile categorica 
```{r}
# 4) Seleziono solo le colonne che mi servono
istat_pop_com_PR_2023 <- dati_finali_com |> 
  dplyr::select(
    #FREQ,  # A
    REF_AREA,
    INDICATOR,
    GENDER,
    AGE_CLASS,
    #MARITAL_STATUS,
    CITIZENSHIP,
    #AREA_CONTRY_CITIZEN,
    #USUAL_RESID_1Y,
    #NOTE_AREA_CONTRY_CITIZEN,
    #TIME_PERIOD,
    OBS_VALUE,
   # NOTE_REF_AREA
  ) |> 
  filter(INDICATOR == "RESPOP_AV")  # solo popolazione residente

```


##### Popolazione per classi decennali di et√† per comuni di Parma (PR) - Censimento 2023

Quindi filtro per Total o ALL dove non mi interessa la variabile

```{r}
# PEr ogni classe di et√† dovrei avere il 44 righe
istat_pop_com_PR_2023_AGE <-  istat_pop_com_PR_2023 |>
  dplyr::filter(INDICATOR == "RESPOP_AV" &  GENDER == "T" & 
                  CITIZENSHIP == "TOTAL"
                  )
```

##### Popolazione per sesso per comuni di Parma (PR) - Censimento 2023
```{r}
istat_pop_com_PR_2023_GENDER <-  istat_pop_com_PR_2023 |>
  dplyr::filter(INDICATOR == "RESPOP_AV" &  
                  AGE_CLASS == "TOTAL" &
                  CITIZENSHIP == "TOTAL"
                )
```

##### Popolazione per cittadinanza per comuni di Parma (PR) - Censimento 2023
```{r}
istat_pop_com_PR_2023_CITIZENSHIP <-  istat_pop_com_PR_2023 |>
  dplyr::filter(INDICATOR == "RESPOP_AV" &  
                  AGE_CLASS == "TOTAL" &  GENDER == "T"
                )
```


#### Salvo files `istat_pop_com_PR_2023*`

[Ridondante: SE ho solo riscaricato da prima]

```{r}
#------------
# In aggiunta io poi salvo
CARTELLA_OUTPUT <- here("data", "data_out")

# Faccio lista di oggetti che iniziano con istat_pop_com_PR_2023
list_obj_istat_pop_com_PR_2023 <- ls(pattern = "^istat_pop_com_PR_2023")

# Salvo ciascun oggetto della lista come RDS e CSV nella CARTELLA_OUTPUT
for (obj_name in list_obj_istat_pop_com_PR_2023) {
  obj <- get(obj_name)
  
  # Definisci i nomi dei file
  rds_file <- file.path(CARTELLA_OUTPUT, paste0(obj_name, ".rds"))
  #csv_file <- file.path(CARTELLA_OUTPUT, paste0(obj_name, ".csv"))
  
  # Salva come RDS
  saveRDS(obj, file = rds_file)
  
  # Salva come CSV
  #write.csv(obj, file = csv_file, row.names = FALSE)
}
```


### File (scarica) `dati_finali_com_ER`

OKKIO: non lo faccio andare se so che ho gi√† i dati!!!!!

CALL API per ottenere dati censimento 2023 per i `330` **comuni Emilia-Romagna (ER)**

```{r}
#| label: istat_pop_com_ER_2023-TOOLONG
#| eval: true

# 1) Funzioni SDMX
# source(here("R", "f_istat_scarica_cens.R"))
source(here::here("data", "data_out", "ER_shp", "lista_PRO_COM_T_er_vec.R"))
CODICI_COMUNI_ER

# 2) Argomenti obbligatori per f_scarica_istat_blocchi() 
DATASET_ID        <- "IT1,DF_DCSS_POP_DEMCITMIG_TV_2,1.0"
ANNO              <- 2023 # del censimento
CODICI_TERRITORIO2 <- CODICI_COMUNI_ER        # ---------- 330 comuni  QUI SI DECIDE PERIMETRO

# # 3.a) Esguo per fare API get di comuni di Parma
# dati_finali_com_ER <- f_scarica_istat_blocchi(
#   codici_territorio   = CODICI_TERRITORIO2,
#   dataset_id          = DATASET_ID,
#   anno                = ANNO,
#   dimensioni_extra = "......" # per scaricare TUTTI i dati
#    # dimensioni_extra = "..ALL.ALLALL" # per cercare di limitare i dati scaricati
#  
#   # GENDER
#   # AGE_CLASS
#   # MARITAL_STATUS
#   # CITIZENSHIP
#   # AREA_CONTRY_CITIZEN
#   # USUAL_RESID_1Y
# )

# 3.b) [SMARTASS VERSION] Solo se istat_pop_com_ER_2023 NON esiste gi√† nella cartella here(data, data_output) , allora scaricalo
file_rds_ER <- here::here("data", "data_out", "istat_pop_com_ER_2023.rds")
if (file.exists(file_rds_ER)) {
  # Caso 1: il file ESISTE ‚Üí leggo da disco
  dati_finali_com_ER <- readRDS(file_rds_ER)
  
} else {
  # Caso 2: il file NON esiste ‚Üí scarico e salvo
  dati_finali_com_ER <- f_scarica_istat_blocchi(
    codici_territorio   = CODICI_TERRITORIO2,
    dataset_id          = DATASET_ID,
    anno                = ANNO,
    dimensioni_extra = "......" # per scaricare TUTTI i dati
    # dimensioni_extra = "..ALL.ALLALL" # per cercare di limitare i dati scaricati
    # G               
    # AGE_CLASS
    # MARITAL_STATUS
    # CITIZENSHIP
    # AREA_CONTRY_CITIZEN
    # USUAL_RESID_1Y
  ) 
  saveRDS(dati_finali_com_ER, file_rds_ER)
} 

# In pratica posso lasciar stare le colonne che non variano: MARITAL_STATUS, AREA_CONTRY_CITIZEN, USUAL_RESID_1Y, NOTE_AREA_CONTRY_CITIZEN, TIME_PERIOD, NOTE_REF_AREA  (che per√≤ ha NA)
```

##### Controllo file `dati_finali_com_ER`
```{r}
# check
skimr::skim(dati_finali_com_ER$REF_AREA)              # 330 unique    
skimr::skim(dati_finali_com_ER$INDICATOR)             # 2 unique
skimr::skim(dati_finali_com_ER$GENDER)                # 3 unique
skimr::skim(dati_finali_com_ER$AGE_CLASS)             # 13 unique
  tabyl(dati_finali_com_ER$AGE_CLASS)
skimr::skim(dati_finali_com_ER$CITIZENSHIP)           # 3 unique (TOTAL, ITL, FRGAPO)
  tabyl(dati_finali_com_ER$CITIZENSHIP)

# skimr::skim(dati_finali_com_ER$MARITAL_STATUS)        # 1 unique (ALL)
#   tabyl(dati_finali_com_ER$MARITAL_STATUS)

# Solo se ho scaricato tutto di fresco (se no li ho gi√† eliminati)  
# skimr::skim(dati_finali_com_ER$AREA_CONTRY_CITIZEN)   # 1 unique (ALL)
#   tabyl(dati_finali_com_ER$AREA_CONTRY_CITIZEN)
# skimr::skim(dati_finali_com_ER$USUAL_RESID_1Y)        # 1 unique (ALL)
#   tabyl(dati_finali_com_ER$USUAL_RESID_1Y)
# skimr::skim(dati_finali_com_ER$NOTE_AREA_CONTRY_CITIZEN)# 1 unique (ISO__ALL_N1)
#   tabyl(dati_finali_com_ER$NOTE_AREA_CONTRY_CITIZEN)
# skimr::skim(dati_finali_com_ER$TIME_PERIOD)           # 1 unique (2023)
# skimr::skim(dati_finali_com_ER$NOTE_REF_AREA)         # 5 unique (034051_N1 o 038029_N1, ... NA)
#   tabyl(dati_finali_com_ER$NOTE_REF_AREA)
#   

```

#### Creo mini file x variabile categorica 
```{r}
# 4) Seleziono solo le colonne che mi servono
istat_pop_com_ER_2023 <- dati_finali_com_ER |> 
  dplyr::select(
    #FREQ,  # A
    REF_AREA,
    INDICATOR,
    GENDER,
    AGE_CLASS,
    #MARITAL_STATUS,
    CITIZENSHIP,
    #AREA_CONTRY_CITIZEN,
    #USUAL_RESID_1Y,
    #NOTE_AREA_CONTRY_CITIZEN,
    #TIME_PERIOD,
    OBS_VALUE,
   # NOTE_REF_AREA
  )  |> 
  filter(INDICATOR == "RESPOP_AV")  # solo popolazione residente
```

##### Popolazione per classi di et√† per comuni di Emilia-Romagna (ER) - Censimento 2023
```{r}
# PEr ogni classe di et√† dovrei avere il 44 righe
istat_pop_com_ER_2023_AGE <-  istat_pop_com_ER_2023 |>
  dplyr::filter(INDICATOR == "RESPOP_AV" &  GENDER == "T" & 
                  CITIZENSHIP == "TOTAL"
                  )  
```

##### Popolazione per sesso per comuni di Emilia-Romagna (ER) - Censimento 2023
```{r}
istat_pop_com_ER_2023_GENDER <-  istat_pop_com_ER_2023 |>
  dplyr::filter(INDICATOR == "RESPOP_AV" &  
                  AGE_CLASS == "TOTAL" &
                  CITIZENSHIP == "TOTAL"
                )
```

##### Popolazione per cittadinanza per comuni di Emilia-Romagna (ER) - Censimento 2023
```{r}
istat_pop_com_ER_2023_CITIZENSHIP <-  istat_pop_com_ER_2023 |>
  dplyr::filter(INDICATOR == "RESPOP_AV" &  
                  AGE_CLASS == "TOTAL" &  GENDER == "T"
                )
```

##### Salvo files `istat_pop_com_ER_2023_...`

[Ridondante: SE ho solo riscaricato da prima]
```{r}
# Faccio lista di oggetti che iniziano con istat_pop_com_ER_2023
list_obj_istat_pop_com_ER_2023 <- ls(pattern = "^istat_pop_com_ER_2023")  
# Salvo ciascun oggetto della lista come RDS e CSV nella CARTELLA_OUTPUT
for (obj_name in list_obj_istat_pop_com_ER_2023) {
  obj <- get(obj_name)  
  # Definisci i nomi dei file
  rds_file <- file.path(CARTELLA_OUTPUT, paste0(obj_name, ".rds"))
  #csv_file <- file.path(CARTELLA_OUTPUT, paste0(obj_name, ".csv"))  
  # Salva come RDS
  saveRDS(obj, file = rds_file)  
  # Salva come CSV
  #write.csv(obj, file = csv_file, row.names = FALSE)
}
```

### File (crea) `dati_prov_ER_agg`

Obiettivo, aggregare i dati di cui sopra per provincia (`COD_PROV`) in Emilia-Romagna

+ viene fatto "manualmente" basandosi sui dati comunali e sullo shapefile dei comuni per ottenere i codici provincia (COD_PROV)

```{r}
# 0) Cosa ho gi√†= output SDMX a livello comunale in forma lunga (REF_AREA = "034001", ecc.)

# ----SOLO PARMA 
#istat_pop_com_PR_2023 <- readRDS("~/Github/parma-dash/data/data_out/istat_pop_com_PR_2023.rds")

# ------TUTTA EMILIA-ROMAGNA
# istat_pop_com_ER_2023 <- readRDS(here("data", "data_out", "istat_pop_com_ER_2023.rds"))


skimr::skim(istat_pop_com_ER_2023)    # 9 unique
```

Prima attacco il codice provincia ai dati censuari per tutti i comuni di Emilia-Romagna (ER) 
```{r}
# 0) Carico shapefile comuni Emilia-Romagna (ER)
er_comuni_sf <- readRDS(here("data", "data_out", "ER_shp", "ER_comuni_sf.rds"))

# 1) Uso er_comuni_sf per ottenere i codici provincia
tab_comune_prov <- er_comuni_sf |>
  sf::st_drop_geometry() |> # non serve 
  dplyr::select(
    REF_AREA = PRO_COM_T,  # codice ISTAT comune, deve combaciare
    COD_PROV, CC_UTS, COMUNE ) |>
  # in teoria non serve, ma per evitare duplicati in caso di shapefile ‚Äúsporco‚Äù.
  dplyr::distinct() 

head(tab_comune_prov)

# 2) Join per avere COD_PROV e REF_AREA in istat_pop_com_ER_2023
dati_prov_ER <- istat_pop_com_ER_2023 |>
  # # Controllo tipo variabile OBS_VALUE
  dplyr::mutate(OBS_VALUE = as.numeric(OBS_VALUE)
                ) |>
  dplyr::left_join(tab_comune_prov, by = "REF_AREA") |> 
   dplyr::mutate(OBS_VALUE = as.numeric(OBS_VALUE),
                COD_PROV = as.character(COD_PROV),
                CC_UTS = as.character(CC_UTS)
                )  


# Controllo
class(dati_prov_ER)
sum(is.na(dati_prov_ER$COD_PROV)) # deve essere 0
skimr::skim(dati_prov_ER)
```

Poi sommo OBSVALUE per provincia (COD_PROV) per ottenere il totale provinciale, ma rispettando ogni categoria di variabili presenti (GENDER, AGE_CLASS, CITIZENSHIP) 

COMUNE in pratica sparisce e ottengo il dato aggregato per provincia (COD_PROV)

```{r}
dati_prov_ER_agg <- dati_prov_ER |>
  dplyr::group_by(
    # CC_UTS, capoluogo o no lo lascio perche √® a liv comune 
    INDICATOR,  # sono costanti per provincia (ma li tengo per vederli)
    COD_PROV, # quello che mi serve
    # Varianozioni da mantenere
    GENDER,
    AGE_CLASS,
    CITIZENSHIP) |>
  summarise(
    OBS_VALUE = sum(OBS_VALUE, na.rm = TRUE),
    .groups   = "drop"
  )
```                  

##### Popolazione per `classi di et√†` per PROVINCIA di Emilia-Romagna (ER) - Censimento 2023
```{r}
# PEr ogni classe di et√† dovrei avere il 44 righe
istat_pop_prov_ER_2023_AGE <-  dati_prov_ER_agg |>
  dplyr::filter(INDICATOR == "RESPOP_AV" &  GENDER == "T" & 
                  CITIZENSHIP == "TOTAL"
                  )  
```

##### Popolazione per `sesso` per PROVINCIA di Emilia-Romagna (ER) - Censimento 2023
```{r}
istat_pop_prov_ER_2023_GENDER <-  dati_prov_ER_agg |>
  dplyr::filter(INDICATOR == "RESPOP_AV" &  
                  AGE_CLASS == "TOTAL" &
                  CITIZENSHIP == "TOTAL"
                )
```

##### Popolazione per `cittadinanza` per PROVINCIA di Emilia-Romagna (ER) - Censimento 2023
```{r}
istat_pop_prov_ER_2023_CITIZENSHIP <-  dati_prov_ER_agg |>
  dplyr::filter(INDICATOR == "RESPOP_AV" &  
                  AGE_CLASS == "TOTAL" &  GENDER == "T"
                )
``` 

#### Salvo files che iniziano per `istat_pop_prov_ER_2023`

[Ridondante: SE ho solo riscaricato da prima]

```{r}
# Faccio lista di oggetti che iniziano con istat_pop_prov_ER_2023
list_obj_istat_pop_prov_ER_2023 <- ls(pattern = "^istat_pop_prov_ER_2023")  
# Salvo ciascun oggetto della lista come RDS e CSV nella CARTELLA_OUTPUT
for (obj_name in list_obj_istat_pop_prov_ER_2023) {
  obj <- get(obj_name)  
  # Definisci i nomi dei file
  rds_file <- file.path(CARTELLA_OUTPUT, paste0(obj_name, ".rds"))
  #csv_file <- file.path(CARTELLA_OUTPUT, paste0(obj_name, ".csv"))  
  # Salva come RDS
  saveRDS(obj, file = rds_file)  
  # Salva come CSV
  #write.csv(obj, file = csv_file, row.names = FALSE)
}

```


# üüß NEXT 

targets seguendo https://chatgpt.com/share/691b4e48-1360-800f-9025-437822330b82

