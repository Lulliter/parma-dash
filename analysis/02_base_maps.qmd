---
title: "Mappe basate su confini e caratteristiche dei comuni"
subtitle: "Materiale intermedio su dati geografici con R"
date: last-modified
date-format: "DD-MMMM-YYYY"
lang: it

format: html
  # html:
  #   theme: flatly #spacelab
    # css: utils/style.css
    # code-fold: true # redundant bc echo false 
    # toc-depth: 3
    # toc_float: true
    # toc-location: left
    # toc-title: Indice
    # embed-resources: true # external dependencies embedded (Not in ..._files/)

execute:
  eval: true
  echo: false # x mostrare codice anche in file docx
  warning: false
  error: false
  output: false
  
bibliography: bib/CRP_dash.bib
suppress-bibliography: false
---

## R packg

```{r}
#| label: setup

# --- Pacchetti (load but suppress warning) --- 
suppressPackageStartupMessages({
  library(here)
  library(sf)
  library(readxl)
  library(janitor)
  
  library(dplyr, warn.conflicts = FALSE, quietly = TRUE)
  library(stringr, quietly = TRUE)
  library(janitor, quietly = TRUE)
  library(tidyr, quietly = TRUE)
  library(glue, quietly = TRUE)
  
  library(ggplot2, quietly = TRUE)
  library(ggrepel, quietly = TRUE)
  library(leaflet, quietly = TRUE)
  library(tmap, quietly = TRUE)
  
  # library(istat)
})

source(here("R","f_ft_formatting.R"))
source(here::here("R","_parma_colors.R"))
```

## leggi shp files per Emilia-Romagna

**FONTE**: output di `map/01_istat_shp_situas_cens.qmd`

```{r}
# FONTE: ISTAT confini amministrativi al 01/01/2025

# Carica dati Emilia-Romagna in file RDS
er_comuni_sf       <-  readRDS( here("data","data_out","ER_shp","er_comuni_sf.rds"))
# er_provincie_sf    <-  readRDS( here("data","data_out","ER_shp","er_provincie_sf.rds"))
# er_regioni_sf      <-  readRDS( here("data","data_out","ER_shp","er_regioni_sf.rds"))
# er_comuni_pr_sf    <-  readRDS( here("data","data_out","ER_shp","er_comuni_pr_sf.rds"))

# Filtra provincia di Parma
# er_provincie_pr <- dplyr::filter(er_provincie_sf, COD_PROV == "34")
```

## leggi caratt comuni Ita

**FONTE**: output di `map/01_istat_shp_situas_cens.qmd`

```{r}
# Fonte ISTAT: Caratteristiche dei comuni (2025)

# Carica altre caratteristiche comuni Ita
comuni_ita_info_redux_sf <- readRDS("~/Github/parma-dash/data/data_out/comuni_ita_info_redux_sf.rds")
```


## leggi dati censimento

**FONTE**: output di `map/01_istat_shp_situas_cens.qmd`

<!-- 1. Riordino file  (Rivedi `_03_thematic_maps.qmd)` per altro riscarico anche emilia romagna  -->
<!-- 2. Annoto la fonte di questi dati -->

```{r}
# leggi dati popolazione ISTAT 2023 per comuni Parma
istat_pop_com_PR_2023 <- readRDS(here("data", "data_out", "istat_cens_2023", "istat_pop_com_PR_2023.rds"))
# istat_pop_com_ER_2023_prov <- readRDS(here("data", "data_out", "istat_pop_com_ER_2023_prov.rds"))
```


## Join comuni ER + caratt comuni Ita

**OKKIO**: qui avrei le caratteristiche di TUTTI i comuni Ita, ma mi tengo solo quelle di Emilia-Romagna. Entrambe qs df sono sf con geometria.  

```{r}
# verifica classi
COD_REG_i <- "8"  # Emilia-Romagna 

# Drop geometry per join
comuni_ita_info_redux <- comuni_ita_info_redux_sf |> # 7896
  filter(COD_REG == COD_REG_i) |> # 330
  sf::st_drop_geometry()
class(comuni_ita_info_redux)  # data.frame

# Join caratteristiche comuni Ita a 330 comuni Parma 
comuni_er <- er_comuni_sf |> 
  left_join(comuni_ita_info_redux, by = "PRO_COM_T") |> 
  # drop the .y versions
  select(-ends_with(".y")) |>
  # remove .x from the names
  rename_with(~ sub("\\.x$", "", .), ends_with(".x")) |> 
  relocate(Shape_Area, Shape_Leng, geometry, .after = last_col()) |> 
  # turn to factor some variables 
  # ZONA_ALT (1=Montagna interna; 2=Montagna litoranea; 3=Collina interna; 4=Collina litoranea; 5=Pianura; Null quando non disponibile)
  mutate(ZONA_ALT = factor(ZONA_ALT,
                           levels = c(1,2,3,4,5),
                           labels = c("Montagna interna",
                                      "Montagna litoranea",
                                      "Collina interna",
                                      "Collina litoranea",
                                      "Pianura"
                                      ))) |> 
 # DEGURBA_2021 1 = Citt√† o Zone densamente popolate; 2 = Piccole citt√† e sobborghi o Zone a densit√† intermedia di popolazione; 3 = Zone rurali o Zone scarsamente popolate; Null quando non disponibile. Basata su Geostat grid 2021.
      mutate(DEGURBA_2021 = factor(DEGURBA_2021,
                               levels = c(1,2,3),
                               labels = c("Citt√† o Zone densamente popolate",
                                          "Piccole citt√† e sobborghi o Zone a densit√† intermedia di popolazione",
                                          "Zone rurali o Zone scarsamente popolate"
                                          )))

```

# ____

## Prep linee PROVINCE

I confini delle PROV si possono desumere dai comuni con `st_union()` in `summarise()`

**OKKIO**: 
+ con `sf`, quando fai `summarise()` su gruppi le geometrie dei comuni nel gruppo vengono unite (`st_union()`), quindi passi da n comuni ‚Üí 1 poligono per provincia, e gli attributi vengono riassunti per gruppo (in questo caso hai solo COD_PROV, quindi rimane quello).
+ `.groups = "drop"` ottieni un tibble sf non raggruppato 

```{r}
# Linee province Emilia-Romagna (per evidenziare Parma)
prov_er <- comuni_er |>
  group_by(COD_PROV) |>
  # dissolve dei confini comunali per provincia con `st_union()`
  summarise(.groups = "drop")  

# (opzionale ma spesso utile, se ci sono geometrie problematiche)
st_geometry(comuni_er) <- st_make_valid(st_geometry(comuni_er))
st_geometry(prov_er)   <- st_make_valid(st_geometry(prov_er))

```

## [Map/Func] mappa con dummy (COM_ISO, COM_LIT, ZONE_COST_2021)

```{r}
source(here("R","f_make_dummy_map.R"))

# ------ Esempio di mappe con la funzione generica per dummy
#' # Esempio di palette personalizzata
#' blue_dummy_pal <- c("#d8e4f0", "#4d648d")  # chiaro-scuro blu
#' burg_md       <- "#922b3e"                 # borgogna medio
#'
#' # Mappa dei comuni litoranei in Emilia-Romagna
#' f_make_dummy_map(
#'   df_comuni       = comuni_er,
#'   df_prov         = prov_er,
#'   dummy_var       = "COM_LIT",   # deve esistere in df_comuni e valere 0/1
#'   title           = "Comuni litoranei (= {dummy_var})",
#'   caption         = "Fonte: ISTAT (2025) ‚Äî Caratteristiche dei comuni, variabile {dummy_var}",
#'   palette         = blue_dummy_pal,  # (definito sopra)
#'   fill_alpha      = 0.75,
#'   highlight_parma = TRUE,
#'   highlight_color = burg_md,         # (definito sopra)
#'   legend_width    = 20
#' )
```
 
 
## [Map] Dummy ZONE_COST_2021 
```{r}
#| label: fig-map-dummy-comiso
#| output: true
#| fig-cap: ""
#| out-width: 100%


fonte_anno_agg <- "Istat/SITUAS (2025)"
fonte_nome <- "Comuni - Caratteristiche del territorio"

f_make_dummy_map(
  df_comuni = comuni_er,
  df_prov   = prov_er,
  dummy_var       = "COM_LIT",
  title     = "Comuni litoranei (= {dummy_var})", # OK glue
  caption   = "Fonte: {fonte_anno_agg} ‚Äî {fonte_nome}", # OK GLUE 
  palette   = c("#c7eae5","#f6e8c3"), #.  div_dummy_ter[c(3,1)] ,         # OK personal palette
  fill_alpha      = 0.75,      # <--- base semi-trasparente
  highlight_parma = TRUE,      # <--- contorno Parma evidenziato
  legend_width    = 20         # <--- wrap etichette legenda
  )

```

## [Map/Func] mappa con fattori (DEGURBA_2021, ZONA_ALT)

```{r}
source(here("R","f_make_factor_map.R"))

#' # Esempio: mappa per una variabile a 3 livelli (es. classi di urbanizzazione)
#'
#' # Palette personalizzata per 3 categorie
#' urb_pal <- c("#d8e4f0", "#4d648d", "#c94c4c")
#'
#' # Assumendo che:
#' # - comuni_er sia un sf con i comuni
#' # - prov_er sia un sf con le province (coerente con comuni_er)
#' # - la variabile "CL_URB" codifichi la classe di urbanizzazione
#'
#' p_factor <- f_make_factor_map(
#'   df_comuni       = comuni_er,
#'   df_prov         = prov_er,
#'   factor_var             = "CL_URB",
#'   title           = "Classi di urbanizzazione (= {factor_var})",
#'   caption         = "Fonte: ISTAT (2025) ‚Äî Caratteristiche dei comuni, variabile {factor_var}",
#'   palette         = urb_pal,   # un colore per ciascun livello del factor
#'   fill_alpha      = 0.9,
#'   highlight_parma = TRUE,
#'   highlight_color = "#922b3e",
#'   legend_width    = 25
#' )
```

## [Map] Fattore ZONA_ALT
```{r}
#| label: fig-map-factor-zonaalt
#| output: true
#| fig-cap: ""
#| out-width: 100%

fonte_anno_agg <- "Istat/SITUAS (2025)"
fonte_nome <- "Comuni - Caratteristiche del territorio"

# div_factor_ter
# "#8c510a" "#bf812d" "#dfc27d" "#f6e8c3" "#c7eae5" "#80cdc1" "#35978f" "#01665e"

f_make_factor_map(
  df_comuni = comuni_er,
  df_prov   = prov_er,
  factor_var       = "ZONA_ALT",
  title        = "Zone altimetriche ( = {factor_var})",
  caption      = "Fonte: {fonte_anno_agg} ‚Äî {fonte_nome}", # OK GLUE 
  fill_alpha   = 0.8,
  comuni_color = "#636363",
  #comuni_lwd   = 0.2,
  palette      =  c("#bf812d", "#dfc27d" ,"#f6e8c3","#c7eae5","#01665e"),
  highlight_parma = TRUE
)
```


## [Map] Fattore DEGURBA_2021
```{r}
#| label: fig-map-factor-degurba
#| output: true
#| fig-cap: ""
#| out-width: 100%


fonte_anno_agg <- "Istat/SITUAS (2025)"
fonte_nome <- "Comuni - Caratteristiche del territorio"

f_make_factor_map(
  df_comuni    = comuni_er,
  df_prov      = prov_er,
  factor          = "DEGURBA_2021",
  title        = "Grado di urbanizzazione (= {factor_var})",
  caption      = "Fonte: {fonte_anno_agg} ‚Äî {fonte_nome}", # OK GLUE 
  fill_alpha   = 0.5,
  comuni_color = "#636363",
  #comuni_lwd   = 0.2,
  palette      =  NULL, #rev(seq_factor_red)
  highlight_parma = TRUE,
  legend_width = 20
)
```

# ___

# Aggiungiamo variabile continua 

## [Prep] Dati popolazione 2023 + Fattore DEGURBA_2021 per comuni Parma 
```{r}
# --- PREP from long to useful
pop_com_PR_by_age <- istat_pop_com_PR_2023  |>         # 4788 
  # Drop bc they are not changing
  #select(-FREQ, -TIME_PERIOD, -MARITAL_STATUS, -AREA_CONTRY_CITIZEN, -USUAL_RESID_1Y) |> 
  # Filtro 
  dplyr::filter(
    # AGE_CLASS lo lascio variare
    INDICATOR == "RESPOP_AV" & # no RESPOP_MIN_AV
      GENDER == "T" & # no F o M 
      CITIZENSHIP == "TOTAL"  
  )      |>               # 44 
  mutate(OBS_VALUE = as.numeric(OBS_VALUE)) |> 
  group_by(REF_AREA, INDICATOR  )  |> 
  summarise(TotalPop = sum(OBS_VALUE[AGE_CLASS == "TOTAL" ]),
            Over60 = sum(OBS_VALUE[AGE_CLASS %in% c("Y60-69","Y70-79","Y80-89",  "Y90-99", "Y_GE100" )]),
            perc_Over60 = round(Over60/TotalPop * 100,2),
            Over70 = sum(OBS_VALUE[AGE_CLASS %in% c("Y70-79","Y80-89",  "Y90-99", "Y_GE100")]),
            perc_Over70 = round(Over70/TotalPop * 100,2),
            Over80 = sum(OBS_VALUE[AGE_CLASS %in% c("Y80-89",  "Y90-99", "Y_GE100")]),
            perc_Over80 = round(Over80/TotalPop * 100,2),
            Under20 = sum(OBS_VALUE[AGE_CLASS %in% c("Y0-9",  "Y10-19")]),
            perc_Under20 = round(Under20/TotalPop * 100,2),
            Under30 = sum(OBS_VALUE[AGE_CLASS %in% c("Y0-9",  "Y10-19",  "Y20-29")]),
            perc_Under30 = round(Under30/TotalPop * 100,2),
            .groups = "drop"  ) 

# join a comuni_er
comuni_pr_pop <- inner_join(comuni_er, pop_com_PR_by_age, 
                           by = c("PRO_COM_T" = "REF_AREA" ))
class(comuni_pr_pop)  # sf + data.frame

# Arguments
fonte_anno_agg <- "Istat/SITUAS (2025)"
fonte_nome <- "Comuni - Caratteristiche del territorio"

fonte2_anno_agg <- "Istat (2023)"
fonte2_nome <- "Censimento"
```

## [Map 1/2] Variabile continua % Popolazione over 60 anni

```{r}
#| label: fig-map-continuous-over60
#| output: true
#| fig-cap: ""
#| out-width: 100%

library(ggiraph)

# INTERATTIVIT√Ä: Prepara dati per mappa interattiva con ggiraph
# Rimuove apici/virgolette dai nomi comuni per evitare errori con ggiraph
# Crea testo tooltip che apparir√† al passaggio del mouse
comuni_pr_pop_clean <- comuni_pr_pop |>
  mutate(
    comune_clean = gsub("['\"]", "", COMUNE),
    tooltip_txt = paste0(comune_clean,": ", perc_Over60, "% over 60")
  )

map_urb_over60 <- ggplot() +
  # geom_sf_interactive permette interattivit√† (hover mostra tooltip con nome comune)
  geom_sf_interactive(
    data = comuni_pr_pop_clean,
    aes(fill = perc_Over60,
        tooltip = tooltip_txt,        # Testo mostrato al passaggio del mouse
        data_id = comune_clean),
    color = "white",
    linewidth = 0.1
  ) +
  geom_sf(
    data = prov_er[prov_er$COD_PROV == "34", ],
    fill = NA,
    color = "#922b3e",
    linewidth = 0.8
  ) +
  scale_fill_viridis_c(
    name = "% popolazione\nover 60",
    option = "plasma",
    direction = -1
  ) +
  labs(
    title    = "Quota di residenti over 60 anni",
    subtitle = "Comuni della provincia di Parma, anno 2023",
    caption  = glue::glue("Fonte: {fonte2_anno_agg} ‚Äî {fonte2_nome}")
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 12),
    plot.subtitle = element_text(size = 10),
    # Rimuove assi coordinati e griglia per mappa pi√π pulita
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank()
  )


map_urb_over60

saveRDS(map_urb_over60, here("data","maps","map_urb_over60.rds"))
```

## [Map 2/2] Popolazione over 60 anni + Grado di urbanizzazione
```{r}
#| label: fig-map-pop-over60-pr
#| output: true
#| fig-cap: ""
#| out-width: 100%


# OPZIONE 1: Facet per DEGURBA_2021, colore per perc_Over60
# Mostra la distribuzione di perc_Over60 separatamente per ogni livello di urbanizzazione
# INTERATTIVIT√Ä: usa geom_sf_interactive per mostrare nome comune al passaggio del mouse
map_urb_over60_fac <- ggplot() +
  geom_sf_interactive(
    data = comuni_pr_pop_clean,
    aes(fill = perc_Over60,
        tooltip = tooltip_txt,
        data_id = comune_clean),
    color = "white",
    linewidth = 0.1
  ) +
  geom_sf(
    data = prov_er[prov_er$COD_PROV == "34", ],
    fill = NA,
    color = "#922b3e",
    linewidth = 0.8
  ) +
  scale_fill_viridis_c(
    name = "% popolazione\nover 60",
    option = "plasma",
    direction = -1
  ) +
  facet_wrap(~DEGURBA_2021, ncol = 3) +
  labs(
    title    = "Quota di residenti over 60 anni per grado di urbanizzazione",
    subtitle = "Comuni della provincia di Parma, anno 2023",
    caption  = glue::glue("Fonte: {fonte2_anno_agg} ‚Äî {fonte2_nome}")
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 12),
    plot.subtitle = element_text(size = 10),
    strip.text = element_text(size = 8, face = "bold"),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank()
  )
map_urb_over60_fac
saveRDS(map_urb_over60_fac, here("data","maps","map_urb_over60_fac.rds"))
```

## [Map] Popolazione over 60 anni + Grado di urbanizzazione
```{r}
#| label: fig-map-pop-over60-pr2
#| output: true
#| fig-cap: ""
#| out-width: 100%
# OPZIONE 2: Bubble map su p_base
# Usa p_base (DEGURBA_2021 come sfondo) + pallini grigi dimensionati per perc_Over60
comuni_pr_pop_centroids <- comuni_pr_pop |>
  st_centroid()

# ADesso uso i dati in comuni_pr_pop ma selezionati solo per Parma
p_base <- f_make_factor_map(
  df_comuni    = comuni_pr_pop,
  df_prov      = prov_er[prov_er$COD_PROV == "34", ], # solo Parma
  factor       = "DEGURBA_2021",
  title        = "Grado di urbanizzazione (= {factor_var})",
  caption      = "Fonte: {fonte_anno_agg} ‚Äî {fonte_nome} \n {fonte2_anno_agg} ‚Äî {fonte2_nome} ", # OK GLUE 
  fill_alpha   = 0.5,
  comuni_color = "#636363",
  #comuni_lwd   = 0.2,
  palette      =  NULL, #rev(seq_factor_red)
  highlight_parma = TRUE,
  legend_width = 20
)

p_base +
  # Pallini grigi con dimensione E tonalit√† proporzionali a perc_Over60
  geom_sf(data = comuni_pr_pop_centroids,
          aes(size = perc_Over60, color = perc_Over60),
          alpha = 0.7,
          show.legend = "point") +
  scale_size_continuous(
    name = "% over 60",
    range = c(1, 8)
  ) +
  scale_color_gradient(
    name = "% over 60",
    low = "#d9d9d9",   # grigio chiaro per % basse
    high = "#252525",  # grigio scuro per % alte
    guide = guide_legend()
  ) +
  labs(
    title    = "Popolazione over 60 e grado di urbanizzazione",
    subtitle = "Comuni della provincia di Parma, anno 2023"
  )

```

## [Stats] Correlazione tra urbanizzazione e invecchiamento

```{r}
# TEST STATISTICO: ANOVA ----
# Testa se le medie differiscono significativamente tra i gruppi
anova_result <- aov(perc_Over60 ~ DEGURBA_2021, data = comuni_pr_pop)
cat("\n=== TEST ANOVA: perc_Over60 ~ DEGURBA_2021 ===\n")
print(summary(anova_result))

# Post-hoc test (confronti multipli)
if(requireNamespace("multcomp", quietly = TRUE)) {
  library(multcomp)
  posthoc <- glht(anova_result, linfct = mcp(DEGURBA_2021 = "Tukey"))
  cat("\n=== POST-HOC TEST (Tukey HSD) ===\n")
  print(summary(posthoc))
}

# Crea tabella statistiche
stats_degurba <- comuni_pr_pop |>
  group_by(DEGURBA_2021) |>
  summarise(
    media = mean(perc_Over60, na.rm = TRUE),
    mediana = median(perc_Over60, na.rm = TRUE),
    sd = sd(perc_Over60, na.rm = TRUE),
    n = n()
  )

# Stampa tabella statistiche
cat("\n=== STATISTICHE DESCRITTIVE ===\n")
print(stats_degurba, n = Inf)
```

```{r}
#| label: fig-stats-degurba-age
#| output: true
#| fig-cap: "Relazione tra grado di urbanizzazione e quota di popolazione over 60"
#| fig-width: 10
#| fig-height: 6

library(patchwork)

#  BOXPLOT: distribuzione di perc_Over60 per categoria DEGURBA
p1 <- ggplot(comuni_pr_pop, aes(x = DEGURBA_2021, y = perc_Over60, fill = DEGURBA_2021)) +
  geom_boxplot(alpha = 0.7, outlier.shape = 21, outlier.size = 2) +
  geom_jitter(width = 0.2, alpha = 0.4, size = 1.5) +
  stat_summary(fun = mean, geom = "point", shape = 23, size = 3, fill = "red") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 15)) +
  labs(
    title = "Distribuzione % over 60 per grado di urbanizzazione",
    x = NULL,
    y = "% popolazione over 60"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(size = 9),
    plot.title = element_text(face = "bold", size = 11)
  )
# Combina i grafici
p1  +
  plot_annotation(
    caption = glue::glue("Fonte: {fonte2_anno_agg} ‚Äî {fonte2_nome}\nComuni della provincia di Parma"),
    theme = theme(plot.caption = element_text(hjust = 0, size = 8))
  )
```

### [Stats/ggstatsplot] Visualizzazione con test integrati

```{r}
#| label: fig-ggstatsplot-degurba-age
#| output: true
#| fig-cap: "Analisi statistica con ggstatsplot"
#| fig-width: 11
#| fig-height: 7

# Usa ggstatsplot per analisi statistiche visuali
library(ggstatsplot)

# Drop geometry per compatibilit√† con ggstatsplot
comuni_pr_pop_df <- comuni_pr_pop |> st_drop_geometry()

# ggbetweenstats: confronto tra gruppi con test statistici integrati
ggbetweenstats(
  data = comuni_pr_pop_df,
  x = DEGURBA_2021,
  y = perc_Over60,
  title = "Correlazione tra grado di urbanizzazione e invecchiamento della popolazione",
  subtitle = "Comuni della provincia di Parma, anno 2023",
  caption = glue::glue("Fonte: {fonte2_anno_agg} ‚Äî {fonte2_nome}"),
  xlab = "Grado di urbanizzazione",
  ylab = "% popolazione over 60",
  # Tipo di plot
  type = "parametric",  # usa ANOVA parametrica
  plot.type = "box",    # boxplot (alt: "violin", "boxviolin")
  # Comparazioni pairwise
  pairwise.comparisons = TRUE,
  pairwise.display = "significant",  # mostra solo quelle significative
  p.adjust.method = "holm",
  # Parametri estetici
  package = "ggsci",
  palette = "default_jco",
  point.args = list(alpha = 0.5, size = 2.5, position = position_jitter(width = 0.15)),
  centrality.plotting = TRUE,
  centrality.type = "parametric",  # mostra la media
  # Labels wrapping
  ggtheme = ggplot2::theme_minimal()
) +
  theme(
    axis.text.x = element_text(size = 9),
    plot.title = element_text(size = 12, face = "bold"),
    plot.subtitle = element_text(size = 10)
  ) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 15))
```

## [Map 1/2] Variabile continua % Popolazione over 70
```{r}
#| label: fig-map-continuous-Over70
#| output: true
#| fig-cap: ""
#| out-width: 100%


# INTERATTIVIT√Ä: Prepara dati per mappa interattiva con ggiraph
# Rimuove apici/virgolette dai nomi comuni per evitare errori con ggiraph
# Crea testo tooltip che apparir√† al passaggio del mouse
comuni_pr_pop_clean <- comuni_pr_pop |>
  mutate(
    comune_clean = gsub("['\"]", "", COMUNE),
    tooltip_txt = paste0(comune_clean,": ", perc_Over70, "% over 70")
  )

map_urb_Over70 <- ggplot() +
  # geom_sf_interactive permette interattivit√† (hover mostra tooltip con nome comune)
  geom_sf_interactive(
    data = comuni_pr_pop_clean,
    aes(fill = perc_Over70,
        tooltip = tooltip_txt,        # Testo mostrato al passaggio del mouse
        data_id = comune_clean),
    color = "white",
    linewidth = 0.1
  ) +
  geom_sf(
    data = prov_er[prov_er$COD_PROV == "34", ],
    fill = NA,
    color = "#922b3e",
    linewidth = 0.8
  ) +
  scale_fill_viridis_c(
    name = "% popolazione\nover 70",
    option = "plasma",
    direction = -1
  ) +
  labs(
    title    = "Quota di residenti over 70 anni",
    subtitle = "Comuni della provincia di Parma, anno 2023",
    caption  = glue::glue("Fonte: {fonte2_anno_agg} ‚Äî {fonte2_nome}")
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 12),
    plot.subtitle = element_text(size = 10),
    # Rimuove assi coordinati e griglia per mappa pi√π pulita
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank()
  )


map_urb_Over70

#map_urb_Over70_interactive <- girafe(ggobj= map_urb_Over70)

saveRDS(map_urb_Over70, here("data","maps","map_urb_Over70.rds"))
```

## [Map 2/2] Popolazione over 70 anni + Zona altimetrica
```{r}
#| label: fig-map-pop-Over70-pr
#| output: true
#| fig-cap: ""
#| out-width: 100%


# OPZIONE 1: Facet per DEGURBA_2021, colore per perc_Over70
# Mostra la distribuzione di perc_Over70 separatamente per ogni livello di urbanizzazione
# INTERATTIVIT√Ä: usa geom_sf_interactive per mostrare nome comune al passaggio del mouse
map_alt_Over70_fac <- ggplot() +
  geom_sf_interactive(
    data = comuni_pr_pop_clean,
    aes(fill = perc_Over70,
        tooltip = tooltip_txt,
        data_id = comune_clean),
    color = "white",
    linewidth = 0.1
  ) +
  geom_sf(
    data = prov_er[prov_er$COD_PROV == "34", ],
    fill = NA,
    color = "#922b3e",
    linewidth = 0.8
  ) +
  scale_fill_viridis_c(
    name = "% popolazione\nover 70",
    option = "plasma",
    direction = -1
  ) +
  facet_wrap(~ZONA_ALT, ncol = 3) +
  labs(
    title    = "Quota di residenti over 70 anni per zona altimetrica",
    subtitle = "Comuni della provincia di Parma, anno 2023",
    caption  = glue::glue("Fonte: {fonte2_anno_agg} ‚Äî {fonte2_nome}")
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 12),
    plot.subtitle = element_text(size = 10),
    strip.text = element_text(size = 8, face = "bold"),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank()
  )
map_alt_Over70_fac

map_alt_Over70_fac_interactive <- girafe(ggobj=map_alt_Over70_fac)
saveRDS(map_alt_Over70_fac, here("data","maps","map_alt_Over70_fac.rds"))
```

## [Map 1/2] Variabile continua % Popolazione under 30
```{r}
#| label: fig-map-continuous-Under30
#| output: true
#| fig-cap: ""
#| out-width: 100%


# INTERATTIVIT√Ä: Prepara dati per mappa interattiva con ggiraph
# Rimuove apici/virgolette dai nomi comuni per evitare errori con ggiraph
# Crea testo tooltip che apparir√† al passaggio del mouse
comuni_pr_pop_clean <- comuni_pr_pop |>
  mutate(
    comune_clean = gsub("['\"]", "", COMUNE),
    tooltip_txt = paste0(comune_clean,": ", perc_Under30, "% under 30")
  )

map_urb_Under30 <- ggplot() +
  # geom_sf_interactive permette interattivit√† (hover mostra tooltip con nome comune)
  geom_sf_interactive(
    data = comuni_pr_pop_clean,
    aes(fill = perc_Under30,
        tooltip = tooltip_txt,        # Testo mostrato al passaggio del mouse
        data_id = comune_clean),
    color = "white",
    linewidth = 0.1
  ) +
  geom_sf(
    data = prov_er[prov_er$COD_PROV == "34", ],
    fill = NA,
    color = "#922b3e",
    linewidth = 0.8
  ) +
  scale_fill_viridis_c(
    name = "% popolazione\nunder 30",
    option = "viridis",
    direction = -1
  ) +
  labs(
    title    = "Quota di residenti under 30 anni",
    subtitle = "Comuni della provincia di Parma, anno 2023",
    caption  = glue::glue("Fonte: {fonte2_anno_agg} ‚Äî {fonte2_nome}")
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 12),
    plot.subtitle = element_text(size = 10),
    # Rimuove assi coordinati e griglia per mappa pi√π pulita
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank()
  )


map_urb_Under30

#map_urb_Under30_interactive <- girafe(ggobj= map_urb_Under30)

saveRDS(map_urb_Under30, here("data","maps","map_urb_Under30.rds"))
```

## [Map 2/2] Popolazione under 30 anni + Zona altimetrica
```{r}
#| label: fig-map-pop-Under30-pr
#| output: true
#| fig-cap: ""
#| out-width: 100%


# OPZIONE 1: Facet per DEGURBA_2021, colore per perc_Under30
# Mostra la distribuzione di perc_Under30 separatamente per ogni livello di urbanizzazione
# INTERATTIVIT√Ä: usa geom_sf_interactive per mostrare nome comune al passaggio del mouse
map_alt_Under30_fac <- ggplot() +
  geom_sf_interactive(
    data = comuni_pr_pop_clean,
    aes(fill = perc_Under30,
        tooltip = tooltip_txt,
        data_id = comune_clean),
    color = "white",
    linewidth = 0.1
  ) +
  geom_sf(
    data = prov_er[prov_er$COD_PROV == "34", ],
    fill = NA,
    color = "#922b3e",
    linewidth = 0.8
  ) +
  scale_fill_viridis_c(
    name = "% popolazione\nunder 30",
    option = "viridis",
    direction = -1
  ) +
  facet_wrap(~ZONA_ALT, ncol = 3) +
  labs(
    title    = "Quota di residenti under 30 anni per zona altimetrica",
    subtitle = "Comuni della provincia di Parma, anno 2023",
    caption  = glue::glue("Fonte: {fonte2_anno_agg} ‚Äî {fonte2_nome}")
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 12),
    plot.subtitle = element_text(size = 10),
    strip.text = element_text(size = 8, face = "bold"),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank()
  )
map_alt_Under30_fac
saveRDS(map_alt_Under30_fac, here("data","maps","map_alt_Under30_fac.rds"))

#map_alt_Under30_fac_interactive <- girafe(ggobj=map_alt_Under30_fac)
```


## QUI üü®üüßüå´Ô∏èüü™üü¶
<!-- https://nrennie.rbind.io/talks/rladies-rome-ggplot2/ -->
<!-- https://chatgpt.com/c/690f7059-01a4-8331-bd6b-b95120d078c3 -->
