---
title: "Mappe e Codici confini amministrativi ISTAT"
subtitle: "Materiale intermedio su dati geografici con R"
date: last-modified
date-format: "DD-MMMM-YYYY"
lang: it

format: html
  # html:
  #   theme: flatly #spacelab
    # css: utils/style.css
    # code-fold: true # redundant bc echo false 
    # toc-depth: 3
    # toc_float: true
    # toc-location: left
    # toc-title: Indice
    # embed-resources: true # external dependencies embedded (Not in ..._files/)

execute:
  eval: true
  echo: false # x mostrare codice anche in file docx
  warning: false
  error: false
  output: false
  
bibliography: ../bib/CRP_dash.bib
suppress-bibliography: false
---

## R packg

```{r}
#| label: setup

# --- Pacchetti (load but suppress warning) --- 
library(here)
library(sf)
library(readxl)
library(janitor, warn.conflicts = FALSE, quietly = TRUE)

library(dplyr, warn.conflicts = FALSE, quietly = TRUE)
library(stringr, quietly = TRUE)
library(janitor, quietly = TRUE)
library(tidyr, quietly = TRUE)

library(ggplot2, quietly = TRUE)
library(ggrepel, quietly = TRUE)
library(leaflet, quietly = TRUE)
library(tmap, quietly = TRUE)
library(flextable, quietly = TRUE)

# source(here("R","f_ft_formatting.R"))
```

# \_\_\_

## Carica dati Censimento

```{r}
#| label: urls_esploradati

library(yaml)
# --- URL EsploraDati Istat ---
urls_istat <- read_yaml(here::here("data","istat_queries.yml"))

# Query originale con eta (decenni per tutti i comuni italiani (io chiedo solo per 44 PR tramite arg CODICI_TERRITORIO....
urls_istat$pop_cens_all
```


**FONTE**: [IstatData](https://esploradati.istat.it/databrowser/#/it/censpop) is the new Istat data warehouse.\
**QUERY STRUTTURA**: [Link](https://esploradati.istat.it/SDMXWS/rest/dataflow/IT1/DF_DCSS_POP_DEMCITMIG_TV_2/1.0/?detail=Full&references=Descendants) 
**QUERY DATI**: [Link] = `urls_istat$pop_cens_all`
**DATA AGGIORNAMENTO**: Censimento 2023 **COME OTTENUTO**: Download dati ISTAT CENSIMENTO via API SDMX (vedi `R/f_istat_scarica_cens.R`) **CONTENUTO**: + Dataset ID = "IT1,DF_DCSS_POP_DEMCITMIG_TV_2,1.0"

#### File (scarica/salva) `istat_pop_com_PR_2023`

CALL API per ottenere dati censimento 2023 SOLO per i **comuni di Parma (PR)** e Emilia-Romagna (ER)

```{r}
#| eval: false

# 0) Codici territorio (dal file che hai generato prima)
source(here("data", "data_out", "ER_shp", "lista_PRO_COM_T_er_pr_vec.R"))
#Stringa test codici comuni Parma e PAvia
CODICI_COMUNI_test_PR_PV <- c("034027","018110")
CODICI_PROVINCIA_test_PR_PV <- c("34","18")


# 1) Funzioni SDMX
source(here("R", "f_istat_scarica_cens.R"))
# Qui la `f_scarica_istat()` scarica dati per UN singolo gruppo di codici, poi `f_scarica_istat_blocchi()` = divide i codici in blocchi, chiama f_scarica_istat() più volte, e unisce i risultati
# quindi io devo chiamare SOLO f_scarica_istat_blocchi() con TUTTI i codici che mi servono

# ---  Tutti gli argomenti (3 obbligatori altri opzionali hanno già un default)
    # dati <- f_scarica_istat_blocchi(
    #   codici_territorio = CODICI_TERRITORIO,     # obbligatorio
    #   dataset_id = "...",                        # obbligatorio
    #   anno = 2023,                               # obbligatorio
    #   frequenza = "A",                           # default "A"
    #   dimensioni_extra = "......",               # default "......"
    #   codici_per_blocco = 10,                    # default 10 (era 15)
    #   pausa_tra_richieste = 20,                  # default 20 (era 15)
    #   pausa_dopo_errore = 30,                    # default 30
    #   timeout_sec = 120,                         # default 120 (era 60)
    #   stampa_piano = TRUE                        # default TRUE
    # )

# 2) Argomenti obbligatori per f_scarica_istat_blocchi() 
DATASET_ID        <- "IT1,DF_DCSS_POP_DEMCITMIG_TV_2,1.0"
ANNO              <- 2023 # del censimento
CODICI_TERRITORIO <- CODICI_COMUNI_test_PR_PV        # ---------- QUI SI DECIDE PERIMETRO

# 3) Esguo per fare API get di comuni di Parma
dati_finali <- f_scarica_istat_blocchi(
  codici_territorio   = CODICI_TERRITORIO,
  dataset_id          = DATASET_ID,
  anno                = ANNO,
  dimensioni_extra = "......" # per scaricare TUTTI i dati
   # dimensioni_extra = "..ALL.ALLALL" # per cercare di limitare i dati scaricati
 
  # GENDER
  # AGE_CLASS
  # MARITAL_STATUS
  # CITIZENSHIP
  # AREA_CONTRY_CITIZEN
  # USUAL_RESID_1Y
 
  )
```


```{r}
#------------
# In aggiunta io poi salvo
CARTELLA_OUTPUT <- here("data", "data_out")
NOME_OUTPUT     <- "istat_pop_com_PR_2023"   # ---------- QUI IN BASE A PERIMETRO

# 5) Eseguo e salvo output  
if (!is.null(dati_finali)) {
  glimpse(dati_finali)
  
  if (!dir.exists(CARTELLA_OUTPUT)) {
    dir.create(CARTELLA_OUTPUT, recursive = TRUE)
  }
  
  saveRDS(dati_finali, file = file.path(CARTELLA_OUTPUT, paste0(NOME_OUTPUT, ".rds")))
  write.csv(dati_finali,
            file = file.path(CARTELLA_OUTPUT, paste0(NOME_OUTPUT, ".csv")),
            row.names = FALSE)
}

```

#### File (scarica/salva) `istat_pop_com_ER_2023`

CALL API per ottenere dati censimento 2023 per i **comuni Emilia-Romagna (ER)**

```{r}
#| eval: false

# 1) Funzioni SDMX
# source(here("R", "f_istat_scarica_cens.R"))
source(here::here("data", "data_out", "ER_shp", "lista_PRO_COM_T_er_vec.R"))

# 2) Argomenti obbligatori per f_scarica_istat_blocchi() 
DATASET_ID        <- "IT1,DF_DCSS_POP_DEMCITMIG_TV_2,1.0"
ANNO              <- 2023 # del censimento
CODICI_TERRITORIO2 <- CODICI_COMUNI_ER        # ---------- 330 comuni  QUI SI DECIDE PERIMETRO

# 3) Esguo per fare API get di comuni di Parma
dati_finali <- f_scarica_istat_blocchi(
  codici_territorio   = CODICI_TERRITORIO2,
  dataset_id          = DATASET_ID,
  anno                = ANNO,
  dimensioni_extra = "......" # per scaricare TUTTI i dati
   # dimensioni_extra = "..ALL.ALLALL" # per cercare di limitare i dati scaricati
 
  # GENDER
  # AGE_CLASS
  # MARITAL_STATUS
  # CITIZENSHIP
  # AREA_CONTRY_CITIZEN
  # USUAL_RESID_1Y
 
  )

```


```{r}
NOME_OUTPUT     <- "istat_pop_com_ER_2023" # --------- CAMBIARE PR IN ER
CARTELLA_OUTPUT <- here("data", "data_out")

# QUINDI salvo output  
if (!is.null(dati_finali)) {
  glimpse(dati_finali)
  
  if (!dir.exists(CARTELLA_OUTPUT)) {
    dir.create(CARTELLA_OUTPUT, recursive = TRUE)
  }
  
  saveRDS(dati_finali, file = file.path(CARTELLA_OUTPUT, paste0(NOME_OUTPUT, ".rds")))
  write.csv(dati_finali,
            file = file.path(CARTELLA_OUTPUT, paste0(NOME_OUTPUT, ".csv")),
            row.names = FALSE)
}

```

#### File (crea/salva) `istat_pop_com_ER_2023_prov`

Obiettivo, aggregare i dati di cui sopra per provincia (COD_PROV) in Emilia-Romagna

```{r}
# 0) Cosa ho già= output SDMX a livello comunale in forma lunga (REF_AREA = "034001", ecc.)
# ----SOLO PARMA 
istat_pop_com_PR_2023 <- readRDS("~/Github/parma-dash/data/data_out/istat_pop_com_PR_2023.rds")
# ------TUTTA EMILIA-ROMAGNA
istat_pop_com_ER_2023 <- readRDS(here("data", "data_out", "istat_pop_com_ER_2023.rds"))
class(istat_pop_com_ER_2023)

# 1) Uso er_comuni_sf per ottenere i codici provincia
tab_comune_prov <- er_comuni_sf |>
  sf::st_drop_geometry() |>
  dplyr::select(
    REF_AREA = PRO_COM_T,  # codice ISTAT comune, deve combaciare
    COD_PROV, CC_UTS, COMUNE ) |>
  # in teoria non serve, ma per evitare duplicati in caso di shapefile “sporco”.
  dplyr::distinct() 

head(tab_comune_prov)

# 2) Join per avere COD_PROV in istat_pop_com_ER_2023
dati_prov_ER <- istat_pop_com_ER_2023|>
  # # Controllo tipo variabile OBS_VALUE
  dplyr::mutate(OBS_VALUE = as.numeric(OBS_VALUE)) |>
  dplyr::left_join(tab_comune_prov, by = "REF_AREA")

# Controllo
sum(is.na(dati_prov_ER$COD_PROV)) # deve essere 0
unique(dati_prov_ER$COD_PROV)

# 3) Aggregazione provinciale GENERICA
# Raggruppo per tutte le dimensioni SDMX ....  tranne REF_AREA (comuni), DEN_COM (nome comune) e OBS_VALUE (che si somma)
# id_vars <- setdiff(
#   # TUTTE le colonne
#   names(dati_prov_ER),
#   # MENO queste
#   c("REF_AREA", "COMUNE", "OBS_VALUE")
# )
# Eseguo aggregazione
# istat_pop_com_ER_2023_prov  <- dati_prov_ER |>
#   dplyr::group_by(dplyr::across(dplyr::all_of(id_vars))) |>
#   dplyr::summarise(
#     OBS_VALUE = sum(OBS_VALUE, na.rm = TRUE),
#     .groups   = "drop"
#   )

# 3) Aggregazione provinciale SOLO per alcune variabili di interesse
istat_pop_com_ER_2023_prov <- dati_prov_ER |>
  dplyr::group_by(
    FREQ,
    INDICATOR,
    GENDER,
    AGE_CLASS,
    MARITAL_STATUS,
    CITIZENSHIP,
    AREA_CONTRY_CITIZEN,
    USUAL_RESID_1Y,
    NOTE_AREA_CONTRY_CITIZEN,
    TIME_PERIOD,
    NOTE_REF_AREA,
    COD_PROV
  ) |>
  dplyr::summarise(
    OBS_VALUE = sum(OBS_VALUE, na.rm = TRUE),
    .groups   = "drop"
  )

dplyr::glimpse(istat_pop_com_ER_2023_prov)

# 4) Controllo output
dplyr::glimpse(istat_pop_com_ER_2023_prov)

check_prov_PR <- istat_pop_com_ER_2023_prov |>
    dplyr::filter(COD_PROV == "34") 
```

Controllo incrociato

```{r}
names(istat_pop_com_PR_2023)

# Confronto risultati 1) somma comuni di Parma...
check_prov_PR <- istat_pop_com_PR_2023 |> 
  dplyr::filter(INDICATOR == "RESPOP_AV" & 
                  GENDER == "T" &
                  AGE_CLASS == "TOTAL" &
                  MARITAL_STATUS == "ALL" &
                  CITIZENSHIP == "TOTAL" & 
                  AREA_CONTRY_CITIZEN == "ALL" &
                  USUAL_RESID_1Y == "ALL" &
                  #NOTE_AREA_CONTRY_CITIZEN == "ISO__ALL_N1" &
                  TIME_PERIOD == 2023 ) |> 
  select(REF_AREA, OBS_VALUE, NOTE_REF_AREA)  |> 
  mutate(OBS_VALUE = as.numeric(OBS_VALUE))

sum(check_prov_PR$OBS_VALUE) # deve essere 454149

# ... con 2) valore provincia di Parma
names(istat_pop_com_ER_2023_prov)
check_PROV_pr <- istat_pop_com_ER_2023_prov |> 
  dplyr::filter(INDICATOR == "RESPOP_AV" &
                  GENDER == "T" &
                  AGE_CLASS == "TOTAL" &
                  MARITAL_STATUS == "ALL" &
                  CITIZENSHIP == "TOTAL" & 
                  AREA_CONTRY_CITIZEN == "ALL" &
                  USUAL_RESID_1Y == "ALL" &
                  #NOTE_AREA_CONTRY_CITIZEN == "ISO__ALL_N1" &
                  TIME_PERIOD == 2023 &
                  COD_PROV == "34" ) |> 
  select(COD_PROV, OBS_VALUE, NOTE_REF_AREA)  |> 
  mutate(OBS_VALUE = as.numeric(OBS_VALUE))

sum(check_PROV_pr$OBS_VALUE) # deve essere 454149                  
```

Salvo

```{r}
# nomi output
NOME_OUTPUT_prov     <- "istat_pop_com_ER_2023_prov" # --------- CAMBIARE PR IN ER
CARTELLA_OUTPUT_prov <- here("data", "data_out")

# 5) Eseguo e salvo output  
if (!is.null(dati_finali)) {
  glimpse(dati_finali)
  
  if (!dir.exists(CARTELLA_OUTPUT_prov)) {
    dir.create(CARTELLA_OUTPUT_prov, recursive = TRUE)
  }
  
  saveRDS(dati_finali, file = file.path(CARTELLA_OUTPUT_prov, paste0(NOME_OUTPUT_prov, ".rds")))
  write.csv(dati_finali,
            file = file.path(CARTELLA_OUTPUT_prov, paste0(NOME_OUTPUT_prov, ".csv")),
            row.names = FALSE)
}
```
