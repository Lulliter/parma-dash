---
title: "Mappe tematiche con dati geografici in R"
subtitle: "Materiale intermedio su dati geografici con R"
date: last-modified
date-format: "DD-MMMM-YYYY"
lang: it

format: html
  # html:
  #   theme: flatly #spacelab
    # css: utils/style.css
    # code-fold: true # redundant bc echo false 
    # toc-depth: 3
    # toc_float: true
    # toc-location: left
    # toc-title: Indice
    # embed-resources: true # external dependencies embedded (Not in ..._files/)

execute:
  eval: true
  echo: false # x mostrare codice anche in file docx
  warning: false
  error: false
  output: false
  
# bibliography: bib/CRP_dash.bib
# suppress-bibliography: false
---


```{r}
#| label: setup
#| eval: true
#| echo: false


# --- Pacchetti (load but suppress warning) --- 
suppressPackageStartupMessages({
  library(here)
  library(sf)
  library(dplyr, warn.conflicts = FALSE, quietly = TRUE)
  library(stringr, quietly = TRUE)
  library(janitor, quietly = TRUE)
  library(tidyr, quietly = TRUE)
  
  library(ggplot2, quietly = TRUE)
  library(ggrepel, quietly = TRUE)
  library(leaflet, quietly = TRUE)
  library(tmap, quietly = TRUE)
  
  library(istat)
})

```

## Leggi dati e mappa di Parma in file RDS

```{r}
#| label: read-rds
# Per leggere i dati
comuni_parma <- readRDS(here("data","data_out","comuni_parma.rds"))
```


# üü• qui

# ISTATDATA

[IstatData](https://esploradati.istat.it/databrowser/#/it/censpop) is the new Istat data warehouse. 

Il pacchetto `istat` fornisce 3 funzioni per scaricare dati:

1. `list_istatdata()`: elenca i dataset disponibili
2. `search_istatdata()`: cerca dataset in base a parole chiave
3. ~~`get_istatdata()`: scarica un dataset specifico~~ (non funziona perch√® non filtrabile)
 

```{r}
#| label: istatdata
#| eval: false

# limite per singolo IP di 5 query al minuto oltre il quale viene attivato un blocco di accesso compreso tra 1 e 2 giorni.

# Installazione pacchetto istatdata (se non gi√† installato)
# install.packages("istat")
library(istat)

# --- Vedi lista
istat_l <- list_istatdata() |>
  janitor::clean_names()

# --- a) Search
# search_istatdata(c("popolazione residente", "comuni"))

# -- b) Filtra con name che contenga "popolazione residente" e "comuni"
# istat_l_pop_com <- istat_l |> 
#   filter(str_detect(name, regex("Popolazione residente", ignore_case = TRUE)) & 
#            str_detect(name, regex("Comuni", ignore_case = TRUE))  
#   )

istat_l_pop_com <- istat_l |> 
  filter(
    stringr::str_detect(name, "(?i)Popolazione residente") & 
    stringr::str_detect(name, "(?i)comuni")
  )

# --- get data (e.g. Popolazione residente per singole et√†, sesso e cittadinanza - comuni)
names(istat_l_pop_com)
# [1] "agency_id" "id"        "version"   "name"   
# data <- get_istatdata(agencyId = "IT1",
#                       dataset_id = "DF_DCSS_POP_DEMCITMIG_SETA_1", 
#                       version = "1.0" 
#                       
# )
  
# Solo Parma
# https://esploradati.istat.it/databrowser/#/it/censpop/categories/CPA_POP/DCSS_POP_DEMCITMIG_TV/IT1,DF_DCSS_POP_DEMCITMIG_TV_2,1.0

```

Posso usare invece il pacchetto `rsdmx` che consente pi√π specifiche. 

### Popolazione residente per comune 

Faccio la richiesta con lo script in `R/scarica_dati_parma.R`

```{r}
#istat_pop_com_PR_2023 <- readRDS("~/Github/parma-dash/data/data_out/istat_pop_com_PR_2023.rds")
istat_pop_com_PR_2023 <- readr::read_csv(here("data/data_out/istat_pop_com_PR_2023.csv"))
istat_pop_com_PR_2023_s <- istat_pop_com_PR_2023 |> 
  select(
    REF_AREA, INDICATOR, GENDER, AGE_CLASS, CITIZENSHIP, TIME_PERIOD, OBS_VALUE)

```

### Choropleth map con stranieri per comune 

```{r}
# Prep data with % obs where CITIZENSHIP == FRGAPO over TOTAL in each REF_AREA
dat_pop_str <- istat_pop_com_PR_2023_s |> 
  filter (GENDER == "T" & AGE_CLASS == "TOTAL")  |> 
  select(REF_AREA, CITIZENSHIP, OBS_VALUE) |>
  # make wide
  pivot_wider(
    names_from = CITIZENSHIP,
    values_from = OBS_VALUE
  ) |>
  mutate(
    pct_frgapo = 100 * FRGAPO / TOTAL
  )

dat_pop_str_join <-  comuni_parma  |> 
  left_join(dat_pop_str, by = c("PRO_COM_T" = "REF_AREA")) |> 
  select(PRO_COM_T, COMUNE, TOTAL, FRGAPO, pct_frgapo, geometry)
    
```

```{r}
library(scales)

# map 
ggplot(dat_pop_str_join) +
  geom_sf(aes(fill = pct_frgapo), color = "white", linewidth = 0.1) +
  scale_fill_gradient(
    name = "% stranieri/apolidi",
    low  = "grey90",
    high = "darkred"
  ) +
  labs(
    title    = "Quota di residenti stranieri/apolidi sul totale",
    subtitle = "Comuni della provincia, anno 2023"
  ) +
  theme_minimal()

```

```{r}
library(ggplot2)

ggplot(dat_pop_str_join) +
  geom_sf(aes(fill = pct_frgapo), color = "white", linewidth = 0.1) +
  geom_sf_text(aes(label = COMUNE), size = 2.5, check_overlap = TRUE) +
  scale_fill_gradient(
    name = "% stranieri/apolidi",
    low  = "grey90",
    high = "darkred"
  ) +
  labs(
    title    = "Quota di residenti stranieri/apolidi sul totale",
    subtitle = "Comuni della provincia, anno 2023"
  ) +
  theme_minimal()

```
