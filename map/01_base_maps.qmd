---
title: "Mappe e Codici confini amministrativi ISTAT"
subtitle: "Materiale intermedio su dati geografici con R"
date: last-modified
date-format: "DD-MMMM-YYYY"
lang: it

format: html
  # html:
  #   theme: flatly #spacelab
    # css: utils/style.css
    # code-fold: true # redundant bc echo false 
    # toc-depth: 3
    # toc_float: true
    # toc-location: left
    # toc-title: Indice
    # embed-resources: true # external dependencies embedded (Not in ..._files/)

execute:
  eval: true
  echo: false # x mostrare codice anche in file docx
  warning: false
  error: false
  output: false
  
bibliography: bib/CRP_dash.bib
suppress-bibliography: false
---

## R packg

```{r}
#| label: setup

# --- Pacchetti (load but suppress warning) --- 
suppressPackageStartupMessages({
  library(here)
  library(sf)
  library(readxl)
  library(janitor)
  
  library(dplyr, warn.conflicts = FALSE, quietly = TRUE)
  library(stringr, quietly = TRUE)
  library(janitor, quietly = TRUE)
  library(tidyr, quietly = TRUE)
  
  library(ggplot2, quietly = TRUE)
  library(ggrepel, quietly = TRUE)
  library(leaflet, quietly = TRUE)
  library(tmap, quietly = TRUE)
  
  # library(istat)
})


source(here("R","f_ft_formatting.R"))
```

## Lettura `.shp files` ISTAT
```{r}
#| label: data-load

# =========================================================
# Italia 2025 (ISTAT, WGS84) â€” Lettura, pulizia e mappe
# Requisiti: sf, dplyr, ggplot2
# File attesi nella working directory:
#  - Com01012025_WGS84.shp          (Comuni)
#  - ProvCM01012025_WGS84.shp       (Province/CittÃ  Metropolitane)
#  - Reg01012025_WGS84.shp          (Regioni)
#  - RipGeo01012025_WGS84.shp       (Ripartizioni geografiche)
# =========================================================

# --------- Path shapefiles ---------
data_path <- here("data","data_in","istat_shp_ITA")


# ---------- Lettura shapefile (senza .cpg: forziamo ENCODING=UTF-8) ----------
comuni_ita       <- st_read(here(data_path,"Com01012025","Com01012025_WGS84.shp"),
                        options = "ENCODING=UTF-8", quiet = TRUE)
province_cm_ita  <- st_read(here(data_path,"ProvCM01012025","ProvCM01012025_WGS84.shp"),
                        options = "ENCODING=UTF-8", quiet = TRUE)
regioni_ita      <- st_read(here(data_path,"Reg01012025","Reg01012025_WGS84.shp"),
                        options = "ENCODING=UTF-8", quiet = TRUE)
# ripartizioni <- st_read(here("data","data_in","istat_shp_ITA","RipGeo01012025","RipGeo01012025_WGS84.shp"),
#                         options = "ENCODING=UTF-8", quiet = TRUE) |> 
#   filter (COD_RIP == "2")
```


```{r}
#| label: shp-er
# ---------- Verifica CRS ----------
st_crs(comuni_ita)$epsg
st_crs(province_cm_ita)$epsg
st_crs(regioni_ita)$epsg

# ---------- (IF needed) Allinea layers alla stessa proiezione (EPSG:32632): ----------
crs_target <- st_crs(comuni_ita)
province_cm_ita  <- st_transform(province_cm_ita, crs = crs_target)
regioni_ita      <- st_transform(regioni_ita, crs = crs_target)
# ripartizioni <- st_transform(ripartizioni, crs = crs_target)

# ---------- Filtro Emilia-Romagna (COD_REG == "8") ----------
comuni_er  <- dplyr::filter(comuni_ita,  COD_REG == "8")            # 330
province_er <- dplyr::filter(province_cm_ita, COD_REG == "8")       # 9
regioni_er <- dplyr::filter(regioni_ita, COD_REG == "8")            # 1

# --------- Seleziona Provincia di Parma ----------
prov_parma <- dplyr::filter(province_cm_ita, COD_PROV == "34")
```


```{r}
#| label: shp-lombardia
#| eval: false

# ---------- Filtro Lombardia (COD_REG == "3") ----------
comuni_lombardia  <- dplyr::filter(comuni_ita,  COD_REG == "3")            # 1502
province_lombardia <- dplyr::filter(province_cm_ita, COD_REG == "3")       # 12
regioni_lombardia <- dplyr::filter(regioni_ita, COD_REG == "3")            # 1

st_crs(comuni_lombardia)$epsg
st_crs(province_lombardia)$epsg
st_crs(regioni_lombardia)$epsg
```


```{r}
#| label: recap

# --------- Piccolo riepilogo/check CRS ----------
data.frame(
  layer = c("regioni_er","province_er", "comuni_er"),
  n = c( nrow(regioni_er),nrow(province_er),  nrow(comuni_er)),
  epsg = c(st_crs(regioni_er)$epsg, st_crs(province_er)$epsg, st_crs(comuni_er)$epsg)
  )
```

## ðŸŸ¡ Lettura caratteristiche dei comuni

```{r}
#| label: comuni-info

# ---------- Caratteristiche comuni ISTAT ----------
comuni_info_01_01_2025 <- read_excel(
  here("data","data_in","istat_class_dim_comuni_01_01_2025.xlsx"),
  sheet = "Comuni 01-01-2025",
  col_types = c("text",         # Codice Regione (Ã¨ in formato testo "01", "02", ecc.)
                "text",         # Codice Istat del Comune (alfanumerico)
                "numeric",         # Codice Istat del Comune (numerico)
                "text",         # Denominazione (Italiana e straniera)
                "text",         # Denominazione altra lingua
                "numeric",         # Superficie territoriale (kmq) al 01/01/2024
                "numeric",         # Popolazione legale 2021 (31/12/2021)
                "numeric",         # Popolazione residente al 31/12/2023
                "text",         # Zona altimetrica (Ã¨ codice: "1", "2", ecc.)
                "numeric",         # Altitudine del centro (metri)
                "numeric",         # Comune litoraneo
                "numeric",         # Comune isolano
                "numeric",         # Zone costiere
                "numeric"),         # Grado di urbanizzazione (1-3)
  
  na = c("N.D.", "N.d.", "N.D", "N.d", "ND", "n.d.", "n.d")  # trattale come NA
) |> 
  janitor::clean_names() |>  # pulizia nomi colonne
# Crea col denominazione italiano (se legge "/" prende prima parte)
  mutate(
    nome_comune_it = stringr::str_trim(
      stringr::str_split_fixed(denominazione_italiana_e_straniera,
                               "/", # split = "/"
                               2)[,1] # prende prima parte
      )) |> 
  relocate(nome_comune_it, .before = denominazione_italiana_e_straniera)
```


## Join comuni_info_01_01_2025 con comuni_ita (su codice_istat_del_comune_alfanumerico = PRO_COM_T)

```{r}
#| label: join-comuni-shp

comuni_ita_info_shp <- comuni_ita |> 
  left_join(comuni_info_01_01_2025,
            by = c("PRO_COM_T" = "codice_istat_del_comune_alfanumerico")
  ) |> 
  #relocate(nome_comune_it , .after = COMUNE)) # OK 
  select(
    COD_RIP,
    COD_REG,
    codice_regione,
    COD_PROV,
    COD_UTS,
    CC_UTS,
    COD_CM,
    #codice_istat_del_comune_numerico, # = PRO_COM
    PRO_COM,
    PRO_COM_T,
    COMUNE,
    COMUNE_A,
    nome_comune_it_str =  denominazione_italiana_e_straniera,
    nome_comune_it,
    nome_comune_str = denominazione_altra_lingua,
    pop_leg_31_12_2021 = popolazione_legale_2021_31_12_2021,
    pop_res_31_12_2023 = popolazione_residente_al_31_12_2023,
    alt_m = altitudine_del_centro_metri,
    comune_litoraneo,
    comune_isolano,
    zone_costiere,
    grado_di_urbanizzazione,
    sup_kmq_01_01_2024 = superficie_territoriale_kmq_al_01_01_2024,
    Shape_Area,
    Shape_Leng,
    geometry
  )

```

## Descrizione Attributi limiti comunali
```{r}
#| label: comuni-attrs
#| output: true

comuni_ita_info_shp_vardesc <- tibble::tibble(
  variabile = c(
    "COD_RIP", 
    "COD_REG", # 1
    "codice_regione", # 01
    "COD_PROV",
    "COD_UTS", 
    "CC_UTS",
    "COD_CM",
    
    "PRO_COM",
    "PRO_COM_T",
    
    "COMUNE",
    "COMUNE_A",
    "nome_comune_it_str",
    "nome_comune_it",
    "nome_comune_str",
    
    "pop_leg_31_12_2021", 
    "pop_res_31_12_2023", 
    "alt_m",
    "comune_litoraneo", 
    "comune_isolano", 
    "zone_costiere",
    "grado_di_urbanizzazione", 
    "sup_kmq_01_01_2024",
    "Shape_Area", 
    "Shape_Leng", 
    "geometry"
  ) ,
  descrizione = c(
    "Codice ripartizione geografica",
    "Codice num regione",
    "Codice alfanum della regione",
    "Codice num provincia",
    "Codice UTS (UnitÃ  Territoriali Sovracomunali)",
    "Capoluogo di provincia o cittÃ  metropolitana.",
    "Codice della cittÃ  metropolitana (###)",
    
    "Codice numerico del comune",
    "Codice alfanumerico del comune",
    
    "Denominazione del comune (italiana/straniera)",
    "Denominazione del comune (altra lingua)",
    "Denominazione del comune (italiana/straniera)",
    "Denominazione del comune (solo italiana)",
    "Denominazione del comune (altra lingua)",
    
    "Popolazione legale al 31/12/2021",
    "Popolazione residente al 31/12/2023",
    "Altitudine s.l.m. del centro (metri)",
    "Comune litoraneo (S/N)",
    "Comune isolano (S/N)",
    "Zone costiere (S/N)",
    "Grado di urbanizzazione",
    
    "Superficie territoriale (kmq) al 01/01/2024",
    "Area geometrica (unitÃ  CRS)",
    "Lunghezza geometrica (unitÃ  CRS)",
    "Geometria (poligono)"
  ) ,
  valori_possibili = c(
    "1=Nord-Ovest, 2=Nord-Est, 3=Centro, 4=Sud, 5=Isole",
    "1-20 (vedi elenco regioni)",
    "01-20 (vedi elenco regioni)",
    "01-111 (vedi elenco province/cittÃ  metropolitane)",
    "Codice num provincia, cittÃ  metropolitana, libero consorzio di comuni o ex provincia",
    "(1=Comune capoluogo; 0=Comune non Ã¨ capoluogo)",
    "Codice num = 200 + COD_PROV",
    
    "Codice num = COD_PROV + COD_CM",
    "Codici alfanumerici = (00)COD_PROV + COD_CM",
    "Stringhe di testo",
    "Stringhe di testo",
    "Stringhe di testo",
    "Stringhe di testo",
    "Stringhe di testo",
    
    "Numerici interi",
    "Numerici interi",
    "Numerici interi",
    "1=Comune litoraneo, 0=Comune non litoraneo",
    "1=Comune isolano, 0=Comune non isolano",
    "1=  Zone costiere,0=  Zone non costiere",
    "1 = CittÃ  o densamente popolate; 2 = Piccole cittÃ  o densitÃ  intermedia, 3 =  Zone rurali o scarsamente popolate",
    "Numerici decimali",
    "Numerici decimali",
    "Numerici decimali",
        "Geometria (poligono)"

  )
)


comuni_ita_info_shp_vardesc_ft <- comuni_ita_info_shp_vardesc |> 
flextable::flextable()  |> 
  f_ft_word()

comuni_ita_info_shp_vardesc_ft
```


## ðŸŸ¡ Tabelle codici utili





### Coordinate Reference System (CRS)
Generalmente, si usano 2 tipi di CRS:

1. un sistema di **coordinate geografiche** (long/lat) in `WGS84 (EPSG:4326)` ( = `CRS AUTHORITY:CODE`). 
2. un sistema di **coordinate proiettate**

I dati ISTAT sono in `UTM 32N (EPSG:32632)`, che Ã¨ un sistema di **coordinate proiettate** (in metri).

Lavorando con mappe di piccole aree (come una regione), Ã¨ preferibile usare un sistema di coordinate proiettate, che mantiene meglio le distanze e le aree.

In `ggplot2` / `sf` si puÃ²:

1. usare `coord_sf(datum = NA)` per evitare che `ggplot2` tenti di trasformare le coordinate in lat/long per la visualizzazione.
2. oppure trasformare i dati in lat/long con `coord_sf(crs = st_crs(4326))` o `st_transform()`.

```{r}
#| eval: true
#| echo: false
#| output: false
#| warning: false

# --------- Verifica CRS ----------
st_crs(comuni_er)

# Varie info sul CRS
st_crs(comuni_er)$epsg # 32632 -> UTM32N
st_crs(comuni_er)$units_gdal # FALSE -> non Ã¨ in latlong
st_crs(comuni_er)$IsProjected  # TRUE -> Ã¨ in proiezione
st_is_longlat(comuni_er) # FALSE -> non Ã¨ in latlong

# Calcolo area (in m2) del primo comune
st_area(comuni_er)[[1]]

# ---- to transform to latlong (WGS84) ----
# comuni_er_ll <- st_transform(comuni_er, crs = 4326)

```


## [Map] Confini Emilia-Romagna, province e comuni

```{r}
#| label: fig-map-base
#| output: true
#| fig-cap: ""
#| out-width: 100%

p <- ggplot() +
  geom_sf(data = comuni_er, fill = "#F4F4F4", color = "grey75", linewidth = 0.08) +
  geom_sf(data = province_er, fill = NA, color = "#4E79A7", linewidth = 0.4) +
  geom_sf(data = regioni_er, fill = NA, color = "#1B263B", linewidth = 0.8) +
  coord_sf(datum = NA) +
  labs(
    title = "Emilia-Romagna â€” Base amministrativa",
    subtitle = "Comuni, Provincie, Regione",
    caption = "Fonte: ISTAT â€” Limiti amministrativi al 01/01/2025"
  ) +
  # Evita problemi di rendering in HTML
  coord_sf(datum = NA) +
  # x evitare che le etichette degli assi vengano visualizzate
  theme(panel.background = element_rect(fill = "#F8F9FA", colour = NA))

print(p)
```

## [Map] ... con Parma in rosso

```{r}
#| label: fig-map-parma
#| output: true
#| fig-cap: ""
#| out-width: 100%


p2 <- ggplot() +
  geom_sf(data = comuni_er, fill = "#F4F4F4", color = "grey75", linewidth = 0.08) +
  geom_sf(data = province_er, fill = NA, color = "#4E79A7", linewidth = 0.4) +
  #geom_sf(data = regioni_er, fill = NA, color = "#1B263B", linewidth = 0.8) +
  # Evidenzia Parma
  geom_sf(data = prov_parma, fill = NA, color = "#873C4A", linewidth = 1.2) +
  coord_sf(datum = NA) +
  labs(
    title = "Emilia-Romagna â€” Base amministrativa",
    subtitle = "Comuni, Provincie, Regione",
    caption = "Fonte: ISTAT â€” Limiti amministrativi al 01/01/2025"
  ) +
  # Evita problemi di rendering in HTML
  coord_sf(datum = NA) +
  # Tema (colore e rimozione griglia e assi)
  theme(
    panel.background = element_rect(fill = "#F8F9FA", colour = NA),
    panel.grid = element_blank(),
    axis.title = element_blank(),
    # axis.text = element_blank(),
    # axis.ticks = element_blank()
  ) 

print(p2)
```

## [Map] ... con Parma in rosso (etichetta)

```{r}
#| label: fig-label-parma
#| output: true
#| fig-cap: ""
#| out-width: 100%

prov_parma_lbl <- prov_parma |>
  mutate(label = "Parma", geometry = st_point_on_surface(geometry))

p3 <- ggplot() +
  geom_sf(data = comuni_er, fill = "#F4F4F4", color = "grey75", linewidth = 0.08) +
  geom_sf(data = province_er, fill = NA, color = "#4E79A7", linewidth = 0.4) +
  # geom_sf(data = regioni_er, fill = NA, color = "#1B263B", linewidth = 0.8) +
  # Evidenzia Parma
  geom_sf(data = prov_parma, fill = NA, color = "#873C4A", linewidth = 1.2) +
  # Aggiungi etichetta Parma
  geom_sf_text(data = prov_parma_lbl, aes(label = label), size = 4) +
  coord_sf(datum = NA) +
  theme(
    panel.background = element_rect(fill = "#F8F9FA", colour = NA),
    panel.grid = element_blank(),
    axis.title = element_blank(),
    # axis.text = element_blank(),
    # axis.ticks = element_blank()
  ) +
  labs(
    title = "Emilia-Romagna â€” Base amministrativa",
    subtitle = "Comuni, Provincie, Regione",
    caption = "Fonte: ISTAT â€” Limiti amministrativi al 01/01/2025"
  )
  # Togli x e y 

print(p3)
```

## [Map] Confini solo Parma, comuni
```{r}
#| label: fig-map-comuni-parma
#| output: true
#| fig-cap: ""
#| out-width: 100%

comuni_parma <- dplyr::filter(comuni_er, COD_PROV == "34")

p4 <- ggplot() +
  geom_sf(data = comuni_parma, fill = "#f5f5f5", color = "#6a6a6a", linewidth = 0.08) +
  geom_sf(data = prov_parma, fill = NA, color = "#873C4A", linewidth = 1.2) +
  coord_sf(datum = NA) +
  labs(
    title = "Provincia di Parma â€” Comuni",
    subtitle = "Comuni in grigio chiaro, confine provinciale in rosso",
    caption = "Fonte: ISTAT â€” Limiti amministrativi al 01/01/2025"
  ) +
  # Tema (colore e rimozione griglia e assi)
  theme(
    panel.background = element_rect(fill = "#F8F9FA", colour = NA),
    panel.grid = element_blank(),
    axis.title = element_blank(),
    # axis.text = element_blank(),
    # axis.ticks = element_blank()
  ) 

print(p4)
```


## [Map] ... con etichette dei comuni

Ci sono varie opzioni per aggiungere etichette ai poligoni:

+ [`geom_text`] (posiziona le etichette al centroide del poligono, puÃ² sovrapporsi)
+ `geom_sf_text` (simile a `geom_text`, ma specifico per oggetti `sf`, con opzione `check_overlap = TRUE`)
+ ...

che usano una variabile di testo (ad esempio `COMUNE`).
```{r}
#| label: fig-map-comuni-label
#| output: true
#| fig-cap: ""
#| out-width: 100%


 
p5 <- ggplot() +
  geom_sf(data = comuni_parma, fill = "#f5f5f5", color = "#6a6a6a", linewidth = 0.08) +
  geom_sf(data = prov_parma, fill = NA, color = "#873C4A", linewidth = 1.2) +
  # Aggiungi etichette dei comuni
  geom_sf_text(data = comuni_parma, aes(label = COMUNE), size = 3, 
               check_overlap = TRUE) +
  # # Oppure
  # geom_text_repel(
  #   data = st_coordinates(st_centroid(comuni_parma)) |> 
  #     as.data.frame() |> 
  #     cbind(COMUNE = comuni_parma$COMUNE),
  #   aes(X, Y, label = COMUNE),
  #   size = 3,
  #   max.overlaps = 20
  # ) +
  
  coord_sf(datum = NA) +
  labs(
    title = "Provincia di Parma â€” Comuni",
    subtitle = "Comuni in grigio chiaro, confine provinciale in rosso",
    caption = "Fonte: ISTAT â€” Limiti amministrativi al 01/01/2025"
  ) +
  # Tema (colore e rimozione griglia e assi)
  theme(
    panel.background = element_rect(fill = "#F8F9FA", colour = NA),
    panel.grid = element_blank(),
    axis.title = element_blank(),
    # axis.text = element_blank(),
    # axis.ticks = element_blank()
  )

print(p5)
```

## [Map] ... con etichette dei comuni WRAPPED

```{r}
#| label: fig-map-comuni-labelwrap
#| output: true
#| fig-cap: ""
#| out-width: 100%

# Funzione per wrappare il testo
comuni_parma <- comuni_parma |> 
  # sostituisce primo spazio con \n
  mutate(COMUNE_WRAP = stringr::str_replace(COMUNE, "\\s", "\n")  )

 
p5 <- ggplot() +
  geom_sf(data = comuni_parma, fill = "#f5f5f5", color = "#6a6a6a", linewidth = 0.08) +
  geom_sf(data = prov_parma, fill = NA, color = "#873C4A", linewidth = 1.2) +
  # Aggiungi etichette dei comuni
  geom_sf_text(data = comuni_parma, 
               aes(label = COMUNE_WRAP), size = 3, 
               check_overlap = TRUE) +
  # # Oppure
  # geom_text_repel(
  #   data = st_coordinates(st_centroid(comuni_parma)) |> 
  #     as.data.frame() |> 
  #     cbind(COMUNE = comuni_parma$COMUNE),
  #   aes(X, Y, label = COMUNE),
  #   size = 3,
  #   max.overlaps = 20
  # ) +
  
  coord_sf(datum = NA) +
  labs(
    title = "Provincia di Parma â€” Comuni",
    subtitle = "Comuni in grigio chiaro, confine provinciale in rosso",
    caption = "Fonte: ISTAT â€” Limiti amministrativi al 01/01/2025"
  ) +
  # Tema (colore e rimozione griglia e assi)
  theme(
    panel.background = element_rect(fill = "#F8F9FA", colour = NA),
    panel.grid = element_blank(),
    axis.title = element_blank(),
    # axis.text = element_blank(),
    # axis.ticks = element_blank()
  )

print(p5)
```



## [Map] ... con etichette dei comuni e righe di collegamento

See tutorial on [Labelling sf objects](https://ggrepel.slowkow.com/articles/examples.html#label-sf-objects)

+ `geom_text_repel` da `ggrepel` (con linee di collegamento opzionali)
  + with argument `stat = "sf_coordinates"` which will enable the `ggrepel` functions to work with spatial `sf` objects directly.

```{r}
#| label: fig-map-comuni-label-repel
#| output: true
#| fig-cap: ""
#| out-width: 100%


# --- Plot
p5b <- ggplot() +
  geom_sf(data = comuni_parma, fill = "#f5f5f5", color = "#6a6a6a", linewidth = 0.08) +
  geom_sf(data = prov_parma, fill = NA, color = "#873C4A", linewidth = 1,
          alpha = 0.5
          ) +
  # --- Aggiungi etichette dei comuni con linee di collegamento
  geom_text_repel(data = comuni_parma,
                  aes(label = COMUNE, geometry = geometry),
                  # -- if using sf object
                  stat = "sf_coordinates",
                  size = 3,
                  # -- mostra tutte le etichette
                  max.overlaps = Inf,
                  # -- stanghette di collegamento
                  segment.color = "#873C4A",
                  segment.alpha = 0.6,
                  segment.size = 1,
                  #segment.linetype = "dashed",
                  min.segment.length = 1, # quanto deve essere x mostrarlo
                  # -- Pad per evitare sovrapposizioni
                  box.padding = 0.5,
                  point.padding = 0.5,
                  # -- Forza verso il centro
                  direction = "both",
                  force = 3,
                  force_pull = 1
                  # # -- Evita i bordi
                  # xlim = c(-Inf, Inf),  # poi aggiungi limiti specifici se serve
                  # ylim = c(-Inf, Inf)
                  
  ) +

  coord_sf(datum = NA) +
  labs(
    title = "Provincia di Parma â€” Comuni",
    subtitle = "Comuni in grigio chiaro, confine provinciale in rosso",
    caption = "Fonte: ISTAT â€” Limiti amministrativi al 01/01/2025"
  ) +
  # Tema (colore e rimozione griglia e assi)
  theme(
    panel.background = element_rect(fill = "#F8F9FA", colour = NA),
    panel.grid = element_blank(),
    axis.title = element_blank(),
    # axis.text = element_blank(),
    # axis.ticks = element_blank()
  )

print(p5b)
```

## [Map] ... con etichette dei comuni e righe di collegamento (limiti per etichette)
```{r}
#| label: fig-map-comuni-label-repel2
#| output: true
#| fig-cap: ""
#| out-width: 100%
#| 
# Calcola i limiti della provincia
bbox <- st_bbox(prov_parma)
x_margin <- (bbox["xmax"] - bbox["xmin"]) * 0.05
y_margin <- (bbox["ymax"] - bbox["ymin"]) * 0.05

p5b <- ggplot() +
  geom_sf(data = comuni_parma, fill = "#f5f5f5", color = "#6a6a6a", linewidth = 0.08) +
  geom_sf(data = prov_parma, fill = NA, color = "#873C4A", linewidth = 1, alpha = 0.5) +
  geom_text_repel(
    data = comuni_parma,
    aes(label = COMUNE, geometry = geometry),
    stat = "sf_coordinates",
    size = 3,
    max.overlaps = Inf,
    # Stanghette
    segment.color = "#873C4A",
    segment.alpha = 0.6,
    segment.size = 1,
    min.segment.length = 1,
    # Padding piÃ¹ aggressivo
    box.padding = 1.2,        # aumentato
    point.padding = 1.2,      # aumentato
    # Forza
    direction = "both",
    force = 5,                # aumentato
    force_pull = 2,           # aumentato
    # CHIAVE: limita l'area delle etichette
    xlim = c(bbox["xmin"] + x_margin, bbox["xmax"] - x_margin),
    ylim = c(bbox["ymin"] + y_margin, bbox["ymax"] - y_margin)
  ) +
  coord_sf(datum = NA) +
  labs(
    title = "Provincia di Parma â€” Comuni",
    subtitle = "Comuni in grigio chiaro, confine provinciale in rosso",
    caption = "Fonte: ISTAT â€” Limiti amministrativi al 01/01/2025"
  ) +
  theme(
    panel.background = element_rect(fill = "#F8F9FA", colour = NA),
    panel.grid = element_blank(),
    axis.title = element_blank()
  )

print(p5b)
```



<!-- https://r-charts.com/spatial/maps-ggplot2/ -->
## [Map Itr] Mappa interattiva che puoi zoomare e leggere il nome del comune

```{r}
#| label: fig-map-leaflet
#| output: true
#| fig-cap: ""
#| out-width: 100%

# 1) Check the current CRS
# st_crs(comuni_parma)
# st_crs(prov_parma)

# 2) If CRS is known (not NA), transform to WGS84 (EPSG:4326)
comuni_parma_ll <- st_transform(comuni_parma, 4326)
prov_parma_ll   <- st_transform(prov_parma, 4326)

# 3) Create interactive map with leaflet
leaflet(data = comuni_parma_ll) |>
  addTiles() |>
  addPolygons(fillColor = "#f5f5f5", color = "#6a6a6a", weight = 0.5,
              label = ~COMUNE, # mostra il nome del comune al passaggio del mouse
              highlightOptions = highlightOptions(color = "blue", weight = 2,
                                                  bringToFront = TRUE)) |>
  addPolygons(data = comuni_parma_ll, fill = NA, color = "#873C4A", weight = 2)
```

## Salva dati e mappa di Parma in file RDS

Il `driver` indica il formato di output (qui `GeoJSON`, oppure `ESRI Shapefile`, `GPKG`, `KML`, ecc.). Di per se `sf` potrebbe estrapolarlo dal suffisso del file, ma Ã¨ meglio specificarlo esplicitamente.

```{r}
#| label: save-rds
#| eval: false

# saveRDS(comuni_parma, file = here("data","data_out","comuni_parma.rds"))
# st_write(obj = comuni_parma, 
#          dsn = here("data","data_out","comuni_parma.geojson"), 
#          driver = "GeoJSON", # Chooses the OGR driver.
#          delete_dsn = TRUE, # overwrite if exists
#          quiet = TRUE # suppress chatter
#          )
# 

```

